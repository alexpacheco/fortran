\documentclass[10pt,t]{beamer}

\include{mypreamble}
\beamertemplateballitem

\newcolumntype{a}{>{\columncolor{lulime}}c}
\newcolumntype{b}{>{\columncolor{lulime!50}}c}
\newcolumntype{d}{>{\columncolor{lulime!40}}c}
\newcolumntype{e}{>{\columncolor{lulime}}l}
\newcolumntype{f}{>{\columncolor{lulime!50}}l}


\hypersetup{
  pdftitle={Modern Fortran}
  pdfauthor={Alexander B. Pacheco, LTS Research Computing, Lehigh University}
}

\title{Modern Fortran Programming I}


\author[Alex Pacheco]{\large{Alexander~B.~Pacheco}}
       
\institute{\href{http://researchcomputing.lehigh.edu}{LTS Research Computing}}

\date{June 1, 2015}
     
\subject{Talks}
\keywords{Lehigh Research Computing Resources, Fortran Programming}
% This is only inserted into the PDF information catalog. Can be left
% out. 


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begingroup
  \setbeamertemplate{background canvas}[vertical shading][bottom=lubrown,top=lubrown]
  \setbeamertemplate{footline}[myfootline] 
  \setbeamertemplate{section page}[mysection]
  \frame[c]{
    \sectionpage
  }
  \endgroup
}

\titlegraphic{\includegraphics[scale=0.5]{lu}}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
  \tableofcontents
\end{frame}


\section{Introduction}
\begin{frame}{What is Fortran?}
  \begin{itemize}
    \item Fortran is a general-purpose, imperative programming language that is especially suited to numeric computation and scientific computing.
    \item Originally developed by IBM for scientific and engineering applications.
    \item The name Fortran is derived from The IBM Mathematical \textbf{For}mula \textbf{Tran}slating System.
    \item It was one of the first widely used "high-level" languages, as well as the first programming language to be standardized. 
    \item It is still the premier language for scientific and engineering computing applications.
  \end{itemize}
\end{frame}

\begin{frame}{Many Flavors of Fortran}
  \begin{itemize}
    \item FORTRAN --- first released by IBM in 1956
    \item FORTRAN II --- released by IBM in 1958
    \item FORTRAN IV --- released in 1962, standardized
    \item FORTRAN 66 --- appeared in 1966 as an ANSI standard
    \item FORTRAN 77 --- appeared in 1977, structured features
    \item Fortran 90 --- 1992 ANSI standard, free form, modules
    \item Fortran 95 --- a few extensions
    \item Fortran 2003 --- object oriented programming
    \item Fortran 2008 --- a few extensions
  \end{itemize}
  The correct spelling of Fortran for 1992 ANSI standard and later (sometimes called Modern Fortran) is "Fortran". Older standards are spelled as "FORTRAN". 
\end{frame}

\begin{frame}{Why Learn Fortran?}
  \begin{itemize}
    \item Fortran was designed by, and for, people who wanted raw number crunching speed. 
    \item There's a great deal of legacy code and numerical libraries written in Fortran,
    \item attempts to rewrite that code in a more "stylish" language result in programs that just don't run as fast.
    \item Fortran is the primary language for some of the most intensive supercomputing tasks, such as 
    \begin{itemize}
      \item astronomy, 
      \item weather and climate modeling, 
      \item numerical linear algebra and libraries, 
      \item computational engineering (fluid dynamics), 
      \item computational science (chemistry, biology, physics), 
      \item computational economics, etc.
    \end{itemize}
    \item How many of you are handed down Fortran code that you are expected to further develop?
  \end{itemize}
\end{frame}

\begin{frame}{Why learn Modern Fortran and not FORTRAN?}
  \begin{itemize}
    \item FORTRAN is a fixed source format dating back to the use of punch cards.
    \item The coding style was very restrictive
    \begin{itemize}
      \item Max 72 columns in a line with
      \item first column reserved for comments indicated by a character such as c or *,
      \item the second through fifth columns reserved for statement labels,
      \item the sixth column for continuation indicator, and
      \item columns 7 through 72 for statements.
      \item Variable names can consists of up to 6 alphanumeric characters (a-z,0-9)
    \end{itemize}
    \item Cannot process arrays as a whole, need to do it element by element.
    \item Cannot allocate memory dynamically.
%    \item Modern Fortran compilers are backwards compatible.
%    \item[] i.e. you can call FORTRAN 77 subroutines and functions from newer code without need for complete rewrite.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{FORTRAN 77 Example}
  \begin{eblock}{SAXPY Code}
    \lstinputlisting[language={[77]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/saxpy.f}
  \end{eblock}
\end{frame}

\begin{frame}{Why Learn Modern Fortran?}
  \begin{itemize}
%    \item Free-format source code and many other simple improvements.
%    \item Arrays as first-class objects, whole-array expressions, assignments, and functions.
%    \item Dynamic memory allocation; pointers to allow complex dynamic data structures to be constructed.
%    \item User-defined data types; existing operators can be overloaded (re-defined) or new ones defined.
%    \item The MODULE - a new program unit which can encapsulate data and a related set of procedures (subroutines or functions). Can implement classes and member functions for object-oriented programming.
%    \item New control structures: SELECT CASE, CYCLE, and EXIT so labels and explicit jumps are rarely needed.
%    \item Recursive functions, generic names for procedures, optional arguments, calls with keywords, and many other procedure call options.
    \item Free-format source code with a maximum of 132 characters per line,
    \item Variable names can consists of up to 31 alphanumeric characters (a-z,0-9) and underscores ( \_ ),
    \item Dynamic memory allocation and Ability to operate on arrays (or array sections) as a whole,
%    \item End of Line comments,
    \item generic names for procedures, optional arguments, calls with keywords, and many other procedure call options,
    \item Recursive procedures and Operator overloading,
    \item Structured data or derived types,
    \item Object Oriented Programming.
    \item See \url{http://en.wikipedia.org/wiki/Fortran\#Obsolescence_and_deletions} for obsolete and deleted FORTRAN 77 features in newer standards.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{FORTRAN 90 Example}
  \begin{eblock}{SAXPY Code}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/saxpy.f90}
  \end{eblock}
\end{frame}

\begin{frame}{Major Differences with C}
  \begin{itemize}
    \item \textbf{No standard libraries:} No specific libraries have to be loaded explicitly for I/O and math.
    \item \textbf{Implicit type declaration:} In Fortran, variables of type real and integer may be declared implicitly, based on their first letter. {\em This behaviour is not recommended in Modern Fortran}.
    \item \textbf{Arrays vs Pointers:} Multi-dimension arrays are supported (arrays in C are one-dimensional) and therefore no vector or array of pointers to rows of a matrices have to be constructed.
    \item \textbf{Call by reference:} Parameters in function and subroutine calls are all passed by reference. When a variable from the parameter list is manipulated, the data stored at that address is changed, not the address itself. Therefore there is no reason for referencing and de-referencing of addresses (as commonly seen in C). 
  \end{itemize}
\end{frame}

\section{Basics}
\begin{frame}[fragile,allowframebreaks]{Fortran Source Code}
  \begin{itemize}
    \item Fortran source code is in ASCII text and can be written in any plain-text editor such as vi, emacs, etc.
    \item For readability and visualization use a text editor capable of syntax highlighting and source code indentation.
    \item Fortran source code is case insensitive i.e. PROGRAM is the same as Program.
    \item Using mixed case for statements and variables is not considered a good programming practice. Be considerate to your collaborators who will be modifying the code.
    \item Some Programmers use uppercase letters for Fortran keywords with rest of the code in lowercase while others (like me) only use lower case letters.
    \item Use whatever convention you are comfortable with and be consistent throughout.
    \item The general structure of a Fortran program is as follows
      \begin{lstlisting}[language={[90]Fortran}]
PROGRAM name
   IMPLICIT NONE
   [specification part]
   [execution part]
   [subprogram part]
END PROGRAM name
      \end{lstlisting}
      \begin{enumerate}
        \item A Fortran program starts with the keyword \lstfortran{PROGRAM} followed by program name,
        \item This is followed by the \lstfortran{IMPLICIT NONE} statement (avoid use of implicit type declaration in Fortran 90),
        \item Followed by specification statements for various type declarations,
        \item Followed by the actual execution statements for the program,
        \item Any optional subprogram, and lastly
        \item The \lstfortran{END PROGRAM} statement
      \end{enumerate}
      \framebreak
    \item A Fortran program consists of one or more program units.
      \begin{itemize}
        \item \lstfortran{PROGRAM}
        \item \lstfortran{SUBROUTINE}
        \item \lstfortran{FUNCTION}
        \item \lstfortran{MODULE}
      \end{itemize}
    \item The unit containing the \lstfortran{PROGRAM} attribute is often called the {\em main program} or {\em main}.
    \item The main program should begin with the \lstfortran{PROGRAM} keyword. This is however not required, but it's use if highly recommended.
    \item A Fortran program should contain only one main program i.e. one \lstfortran{PROGRAM} keyword and can contain one or more subprogram units such as \lstfortran{SUBROUTINE}, \lstfortran{FUNCTION} and \lstfortran{MODULE}.
    \item Every program unit, must end with a \lstfortran{END} keyword.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{}
  \begin{itemize}
  \item Basic Character Set:
    \begin{itemize}
    \item the letters A$\cdots$Z and a$\cdots$z
    \item the digits 0$\cdots$9
    \item the underscore character (\_)
    \item the special characters = \lstinline|: + blank - * / ( ) [ ] , . $ ' ! `` % & ; < > ?|
    \end{itemize}
  \item Identifier: name used to identify a variable, procedure, or any other user-defined item.
    \begin{itemize}
    \item cannot be longer than 31 characters
    \item must be composed of letters, digits and underscores
    \item first character must be a letter
    \item case insensitive
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{}
%  \begin{center}
    \begin{tabular}{ababa}
      \rowcolor{lublue}\multicolumn{5}{c}{Non I/O Keywords}\\
      allocatable & allocate & assign & assignment & block data \\
      call & case & character & common & complex \\
      contains & continue & cycle & data & deallocate \\
      default & do & double precision & else & else if \\
      elsewhere & end block data & end do & end function & end if \\
      end interface & end module & end program & end select & end subroutine \\
      end type & end where & entry & equivalence & exit \\
      external & function & go to & if & implicit \\
      in & inout & integer & intent & interface \\
      intrinsic & kind & len & logical & module \\
      namelist & nullify & only & operator & optional \\
      out & parameter & pause & pointer & private \\
      program & public & real & recursive & result \\
      return & save & select case & stop & subroutine \\
      target & then & type & type() & use \\
      Where & While & & & \\
      \rowcolor{lublue}\multicolumn{5}{c}{I/O Keywords}\\
      backspace & close & endfile & format & inquire \\
      open & print & read & rewind & Write \\
    \end{tabular}
%  \end{center}
\end{frame}

\begin{frame}{Simple I/O}
  \begin{itemize}
    \item Any program needs to be able to read input and write output to be useful and portable.
    \item In Fortran, the \lstfortran{print} command provides the most simple form of writing to standard output while,
    \item the \lstfortran{read} command provides the most simple form of reading input from standard input
    \item \lstfortran{print *, <var1> [, <var2> [, ... ]]}
    \item \lstfortran{read *, <var1> [, <var2> [, ... ]]}
    \item The $\ast$ indicates that the format of data read/written is unformatted.
    \item In later sections, we will cover how to read/write formatted data and file operations.
    \item variables to be read or written should be separated by a comma (,).
  \end{itemize}
\end{frame}

\begin{frame}{Your first code in Fortran}
  \begin{itemize}
    \item Open a text editor and create a file helloworld.f90 containing the following lines
    \lstinputlisting[language={[90]Fortran}]{./Exercise/helloworld.f90}
    \item The standard extension for Fortran source files is .f90, i.e., the source files are named <name>.f90.
    \item The .f extension implies fixed format source or FORTRAN 77 code.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Compiling Fortran Code}
  \begin{itemize}
    \item To execute a Fortran program, you need to compile it to obtain an executable.
    \item Almost all *NIX system come with GCC compiler installed. You might need to install the Fortran (gfortran) compiler if its not present.
    \item Command to compile a fortran program
    \item[] \lstinline|<compiler> [flags] [-o executable] <source code>|
    \item The [...] is optional. If you do not specify an executable, then the default executable is \lstinline|a.out|
      \begin{Verbatim}[fontsize=\fontsize{7}{8}\selectfont,formatcom=\color{indigo}]
altair:Exercise apacheco$ gfortran helloworld.f90 
altair:Exercise apacheco$ ./a.out 
 Hello World!
      \end{Verbatim}
    \item Other compilers available on our clusters are Intel (ifort) and Portland Group (pgf90) compilers.
    \item[] \Verb[fontsize=\fontsize{7}{8}\selectfont,formatcom=\color{indigo}]|ifort -o helloworld helloworld.f90; ./helloworld|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comments}
  \begin{itemize}
    \item To improve readability of the code, comments should be used liberally.
    \item A comment is identified by an exclamation mark or bang (!), except in a character string.
    \item All characters after ! upto the end of line is a comment.
    \item Comments can be inline and should not have any Fortran statements following it
  \end{itemize}
  \begin{eblock}{}
    \begin{lstlisting}[language={[90]Fortran}]
program hello
! A simple Hello World code
  print *, 'Hello World!' ! Print Hello World to screen

! This is an incorrect comment if you want Hello World to print to screen ! print *, 'Hello World!'
end program hello
    \end{lstlisting}
  \end{eblock}
\end{frame}

\begin{frame}[fragile]{Fortran Data Types}
  \begin{itemize}
  \item Fortran provides five intrinsic data types
    \begin{itemize}
    \item[] \lstfortran{INTEGER}: exact whole numbers
    \item[] \lstfortran{REAL}: real, fractional numbers
    \item[] \lstfortran{COMPLEX}: complex, fractional numbers
    \item[] \lstfortran{LOGICAL}: boolean values
    \item[] \lstfortran{CHARACTER}: strings
    \end{itemize}
  \item and allows users to define additional types.
  \item The \lstfortran{REAL} type is a single-precision floating-point number.
  \item The \lstfortran{COMPLEX} type consists of two reals (most compilers also provide a \lstfortran{DOUBLE COMPLEX} type).
  \item FORTRAN also provides \lstfortran{DOUBLE PRECISION} data type for double precision \lstfortran{REAL}. This is obsolete but is still found in several programs.
  \end{itemize}
\end{frame}

\begin{frame}{Explicit and Implicit Typing}
  \begin{itemize}
  \item For historical reasons, Fortran is capable of implicit typing of variables.
    \begin{gather*}
      \underbrace{ABCDEFGH}_{REAL}\overbrace{IJKLMN}^{INTEGER}\underbrace{OPQRSTUVWXYZ}_{REAL}
    \end{gather*}
  \item You might come across old FORTRAN program containing \lstfortran{IMPLICIT REAL*8(a-h,o-z)} or \lstfortran{IMPLICIT DOUBLE PRECISION (a-h,o-z)}.
  \item It is highly recommended to explicitly declare all variable and avoid implict typing using the statement \lstfortran{IMPLICIT NONE}.
  \item The \lstfortran{IMPLICIT} statement must precede all variable declarations.
  \end{itemize}
\end{frame}

\begin{frame}{Variables}
  \begin{itemize}
  \item Variables are the fundamental building blocks of any program.
  \item A variable is nothing but a name given to a storage area that our programs can manipulate.
  \item Each variable should have a specific type,
    \begin{itemize}
    \item which determines the size and layout of the variable's memory;
    \item the range of values that can be stored within that memory; and
    \item the set of operations that can be applied to the variable.
    \end{itemize}
  \item A variable name may consist of up to 31 alphanumeric characters and underscores, of which the first character must be a letter.
  \item Names must begin with a letter and should not contain a space.
  \item Allowed names: a, compute\_force, qed123
  \item Invalid names: 1a, a thing, \$sign
  \end{itemize}
  \begin{center}
    \begin{tabular}{ll}
      \rowcolor{lublue}Type & Description \\
      \rowcolor{lulime!50}Integer & It can hold only integer values. \\
      \rowcolor{lulime}Real & It stores the floating point numbers. \\
      \rowcolor{lulime!50}Complex & It is used for storing complex numbers. \\
      \rowcolor{lulime}Logical & It stores logical Boolean values. \\
      \rowcolor{lulime!50 }Character & It stores characters or strings. \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Constants}
  \begin{itemize}
  \item The constants refer to the fixed values that the program cannot alter during its execution.
  \item Constants can be of any of the basic data types
  \item Literal Constants: has a value but no name
    \begin{center}
      \begin{tabular}{ab}
        \rowcolor{lublue}Type & Example \\
        Integer constants & 0 1 -1 300 123456789 \\
        Real constants & 0.0 1.0 -1.0 123.456 7.1E+10 -52.715E-30 \\
        Complex constants & (0.0, 0.0) (-123.456E+30, 987.654E-29) \\
        Logical constants & .true. .false. \\
        Character constants &         "PQR" "a" "\lstinline|23'abc$%#@!|" \\
      \end{tabular}
    \end{center}
  \item Named Constants:
    \begin{itemize}
    \item has a value as well as a name.
    \item should be declared at the beginning of a program or procedure, indicating its name and type.
    \item are declared with the parameter attribute
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Variable Declarations}
  \begin{itemize}
    \item Variables must be declared before they can be used.
    \item In Fortran, variable declarations must precede all executable statements.
    \item To declare a variable, preface its name by its type.
    \item[] \lstfortran{TYPE Variable}
    \item A double colon may follow the type.
    \item[] \lstfortran{TYPE[, attributes] :: Variable}
    \item This is the new form and is recommended for all declarations. If attributes need to be added to the type, the double colon format must be used.
    \item A variable can be assigned a value at its declaration.
    \framebreak
    \item \textbf{Numeric Variables:}
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER :: i, j = 2
REAL    :: a, b = 4.d0
COMPLEX :: x, y 
      \end{lstlisting}
    \item In the above examples, the value of j and b are set at compile time and can be changed later.
    \item If you want the assigned value to be constant that cannot change subsequently, add the attribute \lstfortran{PARAMETER}
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER, PARAMETER :: j = 2
REAL, PARAMETER    :: pi = 3.14159265
COMPLEX, PARAMETER :: ci = (0.d0,1.d0)
      \end{lstlisting}
    \item \textbf{Logical:} Logical variables are declared with the \lstfortran{LOGICAL} keyword
      \begin{lstlisting}[language={[90]Fortran}]
LOGICAL  :: l, flag=.true.
      \end{lstlisting}
    \item \textbf{Character:} Character variables are declared with the \lstfortran{CHARACTER} type; the length is supplied via the keyword \lstfortran{LEN}.
    \item The length is the maximum number of characters (including space) that will be stored in the character variable.
    \item If the \lstfortran{LEN} keyword is not specified, then by default \lstfortran{LEN=1} and only the first character is saved in memory. 
      \begin{lstlisting}[language={[90]Fortran}]
CHARACTER         :: ans = 'yes' ! stored as y not yes
CHARACTER(LEN=10) :: a
      \end{lstlisting}
    \item FORTRAN programmers: avoid the use of \lstfortran{CHARACTER*10} notation.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Array Variables}
  \begin{itemize}
    \item Arrays (or matrices) hold a collection of different values at the same time.
    \item Individual elements are accessed by subscripting the array.
    \item Arrays are declared by adding the \lstfortran{DIMENSION} attribute to the variable type declaration which can be integer, real, complex or character.
    \item Usage: \lstfortran{TYPE, DIMENSION(lbound:ubound) :: variable_name}
    \item[] Lower bounds of one can be omitted
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER, DIMENSION(1:106) :: atomic_number
REAL, DIMENSION(3, 0:5, -10:10) :: values
CHARACTER(LEN=3), DIMENSION(12) :: months
      \end{lstlisting}
    \item In Fortran, arrays can have upto seven dimension.
    \item In contrast to C/C++, Fortran arrays are column major.
    \item We'll discuss arrays in more details tomorrow.
  \end{itemize}
\end{frame}

\begin{frame}{DATA Statments}
  \begin{itemize}
    \item In FORTRAN, a \lstfortran{DATA} statement may be used to initialize a variable or group of variables.
    \item It causes the compiler to load the initial values into the variables at compile time i.e. a nonexecutable statment
    \item General form
    \item[] \lstfortran{DATA varlist /varlist/ [, varlist /varlist/]}
    \item[] Example \lstfortran{DATA a,b,c /1.,2.,3./}
    \item \lstfortran{DATA} statements can be used in Fortran but it is recommended to to eliminate this statement by initializing variables in their declarations.
    \item In Fortran 2003, variables may be initialized with intrinsic functions (some compilers enable this in Fortran 95)
    \item[] \lstfortran{REAL, PARAMETER :: pi = 4.0*atan(1.0)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{KIND Parameter}
  \begin{itemize}
    \item In FORTRAN, types could be specified with the number of bytes to be used for storing the value:
      \begin{itemize}
        \item \lstfortran{real*4} - uses 4 bytes, roughly $\pm10^{-38}$ to $\pm10^{38}$.
        \item \lstfortran{real*8} - uses 8 bytes, roughly $\pm10^{-308}$ to $\pm10^{308}$.
        \item \lstfortran{complex*16} - uses 16 bytes, which is two \lstfortran{real*8} numbers.
      \end{itemize}
    \item Fortran 90 introduced \lstfortran{kind} parameters to parameterize the selection of different possible machine representations for each intrinsic data types.
    \item The \lstfortran{kind} parameter is an integer which is processor dependent.
    \item There are only 2(3) kinds of reals: 4-byte, 8-byte (and 16-byte), respectively known as single, double (and quadruple) precision.
    \item The corresponding \lstfortran{kind} numbers are 4, 8 and 16 (most compilers)
  \end{itemize}
  \begin{minipage}{\textwidth}
    \begin{center}
      \begin{tabular}{abb}
        \rowcolor{lublue}KIND & Size (Bytes) & Data Type \\
        1 & 1 & integer, logical, character (default) \\
        2 & 2 & integer, logical \\
        4\footnote{\tiny default for all data types except character} & 4 & integer, real, logical, complex \\
        8 & 8 & integer, real, logical, complex \\
        16 & 16 & real, complex \\
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{itemize}
    \item You might come across FORTRAN codes with variable declarations using \lstfortran{integer*4}, \lstfortran{real*8} and \lstfortran{complex*16} corresponding to \lstfortran{kind=4} (integer) and \lstfortran{kind=8} (real and complex).
    \item The value of the \lstfortran{kind} parameter is usually not the number of decimal digits of precision or range; on many systems, it is the number of bytes used to represent the value.
    \item The intrinsic functions \lstfortran{selected\_int\_kind} and \lstfortran{selected\_real\_kind} may be used to select an appropriate \lstfortran{kind} for a variable or named constant.
    \item \lstfortran{selected_int_kind(R)} returns the kind value of the smallest integer type that can represent all values ranging from $-10^R$ (exclusive) to $10^R$ (exclusive)
    \item \lstfortran{selected\_real\_kind(P,R)} returns the kind value of a real data type with decimal precision of at least P digits, exponent range of at least R. At least one of P and R must be specified, default R is 308.
  \end{itemize}

  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]{./Exercise/kindfns.f90}
  \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./kindfns 
Kind of i =  4  with range =   9
Kind of j =  8  with range =  18
Kind of k =  8  with range =  18
Kind of real a =  4  with precision =  6  and range =  37
Kind of real b =  8  with precision = 15  and range = 307
Kind of real c =  8  with precision = 15  and range = 307
  \end{Verbatim}
\end{frame}

\begin{frame}{Operators}
  Fortran defines a number of operations on each data type.
  \begin{columns}[t]
    \column{0.4\textwidth}
    \begin{eblock}{\scriptsize Arithmetic Operators}
      \begin{itemize}
        \footnotesize
        \item[+]: addition
        \item[-]: subtraction
        \item[*]: multiplication
        \item[/]: division
        \item[**]: exponentiation
      \end{itemize}
    \end{eblock}
    \column{0.4\textwidth}
    \begin{eblock}{\scriptsize Relational Operators (FORTRAN versions)}
      \begin{itemize}
        \footnotesize
        \item[==]: equal to (.eq.)
        \item[/=]: not equal to (.ne.)
        \item[<]: less than (.lt.)
        \item[<=]: less than or equal to (.le.)
        \item[>]: greater than (.gt.)
        \item[>=]: greater than or equal to (.ge.)
      \end{itemize}
    \end{eblock}
  \end{columns}
  \begin{columns}[t]
    \column{0.4\textwidth}
    \begin{eblock}{\scriptsize Logical Expressions}
      \begin{itemize}
        \footnotesize
        \item[]{\color{lubrown}.AND.} intersection
        \item[]{\color{lubrown}.OR.} union
        \item[]{\color{lubrown}.NOT.} negation
        \item[]{\color{lubrown}.EQV.} logical equivalence
        \item[]{\color{lubrown}.NEQV.} exclusive or
      \end{itemize}
    \end{eblock}
    \column{0.4\textwidth}
    \begin{eblock}{\scriptsize Character Operators}
      \begin{itemize}
        \footnotesize
        \item[//]: concatenation
      \end{itemize}
    \end{eblock}
  \end{columns}
\end{frame}

\begin{frame}{Operator Evaluations}
  \begin{itemize}
    \item In Fortran, all operator evaluations on variables is carried out from left-to-right.
    \item Arithmetic operators have a highest precedence while logical operators have the lowest precedence
    \item The order of operator precedence can be changed using parenthesis, '(' and ')'
    \item In Fortran, a user can define his/her own operators.
    \item User defined monadic operator has a higher precedence than arithmetic operators, while
    \item dyadic operators has a lowest precedence than logical operators.
  \end{itemize}
\end{frame}
\begin{frame}{ Operator Precedence}
  \begin{center}
    \begin{tabular}{aba}
      \rowcolor{lublue}Operator & Precedence & Example \\
      expression in () & Highest & (a+b) \\
      user-defined monadic & - & .inverse.a \\
      ** & - & 10**4 \\
      * or / & - & 10*20 \\
      monadic + or - & - & -5 \\
      dyadic + or - & - & 1+5 \\
      // & - & str1//str2 \\
      relational operators & - & a > b \\
      .not. & - & .not.allocated(a) \\
      .and. & - & a.and.b \\
      .or. & - & a.or.b \\
      .eqv. or .neqv. & - & a.eqv.b \\
      user defined dyadic & Lowest & x.dot.y\\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Expressions}
  \begin{itemize}
    \item An expression is a combination of one or more operands, zero or more operators, and zero or more pairs of parentheses.
    \item There are three kinds of expressions:
      \begin{itemize}
        \item An arithmetic expression evaluates to a single arithmetic value.
        \item A character expression evaluates to a single value of type character.
        \item A logical or relational expression evaluates to a single logical value.
      \end{itemize}
    \item Examples:
  \end{itemize}
  \begin{lstlisting}
    x + 1.0 
    97.4d0 
    sin(y) 
    x*aimag(cos(z+w)) 
    a .and. b 
    'AB' // 'wxy'
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile, allowframebreaks]{Statements}
  \begin{itemize}
    \item A statement is a complete instruction.
    \item Statements may be classified into two types: executable and non-executable.
    \item Non-executable statements are those that the compiler uses to determine various fixed parameters such as module use statements, variable declarations, function interfaces, and data loaded at compile time.
    \item Executable statements are those which are executed at runtime.
    \item A statements is normally terminated by the end-of-line marker.
    \item If a statement is too long, it may be continued by the ending the line with an ampersand (\&).
    \item Max number of characters (including spaces) in a line is 132 though it's standard practice to have a line with up to 80 characters. This makes it easier for file editors to display code or print code on paper for reading.
    \item Multiple statements can be written on the same line provided the statements are separated by a semicolon.
    \item Examples:
      \begin{lstlisting}[language={[90]Fortran}]
force = 0d0 ; pener = 0d0
do k = 1, 3
   r(k) = coord(i,k) - coord(j,k)
      \end{lstlisting}
    \item Assignment statements assign an expression to a quantity using the equals sign (=)
    \item The left hand side of the assignment statement must contain a single variable.
    \item $x + 1.0 = y$ is not a valid assignment statement.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Intrinsic Functions}
  \begin{itemize}
    \item Fortran provide a large set of intrinsic functions to implement a wide range of mathematical operations.
    \item In FORTRAN code, you may come across intrinsic functions which are prefixed with \texttt{i} for integer variables, \texttt{d} for double precision, \texttt{c} for complex single precision and \texttt{cd} for complex double precision variables.
    \item In Modern Fortran, these functions are overloaded, i.e. they can carry out different operations depending on the data type.
    \item For example: the \lstfortran{abs} function equates to $\sqrt{a^2}$ for integer and real numbers and $\sqrt{\Re^2 + \Im^2}$ for complex numbers.
  \end{itemize}
\end{frame}

\begin{frame}{Arithmetic Functions}
  \footnotesize
  \begin{minipage}{\textwidth}
    \begin{center}
      \begin{tabular}{abd}
        \rowcolor{lublue}Function & Action & Example \\
        INT & conversion to integer & J=INT(X) \\
        REAL & conversion to real & X=REAL(J) \\
        & return real part of complex number & X=REAL(Z) \\
        DBLE\footnote{\tiny use real(x,kind=8) instead} & convert to double precision & X=DBLE(J) \\
        CMPLX & conversion to complex & A=CMPLX(X[,Y]) \\
        AIMAG & return imaginary part of complex number & Y=AIMAG(Z) \\
        ABS & absolute value & Y=ABS(X) \\
        MOD & remainder when I divided by J & K=MOD(I,J) \\
        CEILING & smallest integer $\ge$ to argument & I=CEILING(a) \\
        FLOOR & largest integer $\le$ to argument & I=FLOOR(a) \\
        MAX & maximum of list of arguments & A=MAX(C,D) \\
        MIN & minimum of list of arguments & A=MIN(C,D) \\
        SQRT & square root & Y=SQRT(X) \\
        EXP & exponentiation & Y=EXP(X) \\
        LOG & natural logarithm & Y=LOG(X) \\
        LOG10 & logarithm to base 10 & Y=LOG10(X) \\
      \end{tabular}
    \end{center}
  \end{minipage}
\end{frame}
  
\begin{frame}{Trignometric Functions}
  \footnotesize
  \begin{center}
    \begin{tabular}{abd}
      \rowcolor{lublue}Function & Action & Example \\
      SIN & sine & X=SIN(Y) \\
      COS & cosine & X=COS(Y) \\
      TAN & tangent & X=TAN(Y) \\
      ASIN & arcsine & X=ASIN(Y) \\
      ACOS & arccosine & X=ACOS(Y) \\
      ATAN & arctangent & X=ATAN(Y) \\
      ATAN2 & arctangent(a/b) & X=ATAN2(A,B) \\
      SINH & hyperbolic sine & X=SINH(Y) \\
      COSH & hyperbolic cosine & X=COSH(Y) \\
      TANH & hyperbolic tangent & X=TANH(Y) \\
    \end{tabular}  
  
        {\tiny hyperbolic functions are not defined for complex argument}
  \end{center}
\end{frame}

\begin{frame}{Character Functions}
  \footnotesize
  \begin{center}
    \begin{tabular}{ef}
      \rowcolor{lublue}Function & Description \\
      len(c) & length \\
      len\_trim(c) & length of c if it were trimmed \\
      lge(s1,s2) & returns .true. if s1 follows or is equal to s2 in lexical order \\
      lgt(s1,s2) & returns .true. if s1 follows s1 in lexical order \\
      lle(s1,s2) & returns .true. if s2 follows or is equal to s1 in lexical order \\
      llt(s1,s2) & returns .true. if s2 follows s1 in lexical order \\
      adjustl(s) & returns string with leading blanks removed and \\
      &   \quad same number of trailing blanks added \\
      adjustr(s) & returns string with trailing blanks removed and \\
      & \quad same number of leading blanks added \\
      repeat(s,n) & concatenates string s to itself n times \\
      scan(s,c) & returns the integer starting position of string c within string s \\
      trim(c) & trim trailing blanks from c \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Array Intrinsic Functions}
  \footnotesize
  \begin{description}
    \item[{size(x[,n])}] The size of x (along the $n^{th}$ dimension, optional)
    \item[{sum(x[,n])}] The sum of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $sum(x) = \sum_{i,j,k,\cdots}x_{i,j,k,\cdots}$
    \item[{product(x[,n])}] The product of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $prod(x) = \prod_{i,j,k,\cdots}x_{i,j,k,\cdots}$
    \item[transpose(x)] Transpose of array x: $ x_{i,j}\Rightarrow x_{j,i}$
    \item[dot\_product(x,y)] Dot Product of arrays x and y: $ \sum_{i} x_i* y_i $
    \item[matmul(x,y)] Matrix Multiplication of arrays x and y which can be 1 or 2 dimensional arrays: $ z_{i,j} = \sum_k x_{i,k} * y_{k,j}$
    \item[conjg(x)] Returns the conjugate of x: $ a + \imath b \Rightarrow a - \imath b$
  \end{description}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Simple Temperature Conversion Problem}
  \begin{itemize}
    \item Write a simple program that 
    \begin{enumerate}
      \item Converts temperature from celsius to fahrenheit
      \item Converts temperature from fahrenheit to celsius
    \end{enumerate}
      \begin{columns}[t]
        \column{0.4\textwidth}
        \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/simple.f90}
        \column{0.6\textwidth}
        \begin{lstlisting}[basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
altair:Exercise apacheco$ gfortran simple.f90
altair:Exercise apacheco$ ./a.out 
 10C =    42.0000000     F
 40F =    0.00000000     C
        \end{lstlisting}
      \end{columns}
    \item So what went wrong? $10C = 50F$ and $40F = 4.4C$
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Type Conversion}
  \begin{itemize}
    \item In computer programming, operations on variables and constants return a result of the same type.
    \item In the temperature code, $9/5=1$ and $5/9=0$. Division between integers is an integer with the fractional part truncated.
    \item In the case of operations between mixed variable types, the variable with lower rank is promoted to the highest rank type.
  \end{itemize}
  \begin{center}
    \footnotesize
    \begin{tabular}{abb}
      \rowcolor{lublue}Variable 1 & Variable 2 & Result \\
      Integer & Real & Real \\
      Integer & Complex & Complex \\
      Real & Double Precision & Double Precision \\
      Real & Complex & Complex\\
    \end{tabular}
  \end{center}
  \framebreak
  \begin{itemize}
    \item As a programmer, you need to make sure that the expressions take type conversion into account
      \begin{columns}[t]
        \column{0.4\textwidth}
        \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/temp.f90}
        \column{0.6\textwidth}
        \begin{lstlisting}[basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
altair:Exercise apacheco$ gfortran temp.f90
altair:Exercise apacheco$ ./a.out
 10C =    50.0000000     F
 40F =    4.44444466     C
        \end{lstlisting}
      \end{columns}
    \item The above example is not a good programming practice. 
    \item 10, 40 and 32 should be written as real numbers (10., 40. and 32.) to stay consistent. 
  \end{itemize}
\end{frame}

\begin{frame}{Exercise}
  \begin{itemize}
  \item Write a code to read a radius from standard input and calculate area and circumference of a circle of that radious
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo code for calculating area and circumference}
    \begin{algorithmic}
      \Program{areacircum}{}
      \State Define $\pi$
      \State $r \gets$ some number
      \State $a = \pi{}r^2$
      \State $c = 2\pi{}r$
      \EndProgram{areacircum}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

\section{Control Constructs}
\begin{frame}[fragile] {Control Constructs}
  \begin{itemize}
    \item A Fortran program is executed sequentially
      \begin{lstlisting}[language={[90]Fortran},mathescape]
program somename 
  variable declarations
  statement 1
  statement 2
  $\cdots$
end program somename
      \end{lstlisting}
    \item Control Constructs change the sequential execution order of the program
      \begin{enumerate} %\itemsep1pt \parskip0pt \parsep0pt
        \item Conditionals: \lstfortran{IF}
        \item Loops: \lstfortran{DO}
        \item Switches: \lstfortran{SELECT/CASE}
        \item Branches: \lstfortran{GOTO} (obsolete in Fortran 95/2003, use CASE instead)
      \end{enumerate}
  \end{itemize}
\end{frame}

\subsection{Conditionals}
\begin{frame}[fragile]{If Statement}
  \begin{itemize}
    \item The general form of the \lstfortran{if} statement
    \item[] \lstfortran{if ( expression ) statement}
    \item When the \lstfortran{if} statement is executed, the logical expression is evaluated. 
    \item If the result is true, the statement following the logical expression is executed; otherwise, it is not executed.
    \item The statement following the logical expression \textbf{cannot} be another \lstfortran{if} statement. Use the \lstfortran{if-then-else} construct instead.
    \item[] \lstfortran{if (value < 0) value = 0 }
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{If-then-else Construct}
  \begin{itemize}
    \item The \lstfortran{if-then-else} construct permits the selection of one of a number of blocks during execution of a program
    \item The \lstfortran{if-then} statement is executed by evaluating the logical expression.
    \item If it is true, the block of statements following it are executed. Execution of this block completes the execution of the entire \lstfortran{if} construct.
    \item If the logical expression is false, the next matching \lstfortran{else if}, \lstfortran{else} or \lstfortran{end if} statement following the block is executed.
      \begin{lstlisting}[language={[90]Fortran},mathescape,basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( expression 1) then
  executable statements
else if ( expression 2 ) then
  executable statements
else if $\cdots$
  $\vdots$
else
  executable statements
end if
      \end{lstlisting}
      \framebreak
    \item Examples:
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( x < 50 ) then
  GRADE = 'F'
else if ( x >= 50 .and. x < 60 ) then
  GRADE = 'D'
else if ( x >= 60 .and. x < 70 ) then
  GRADE = 'C'
else if ( x >= 70 .and. x < 80 ) then
  GRADE = 'B'
else 
  GRADE = 'A'
end if
      \end{lstlisting}
    \item The \lstfortran{else if} and \lstfortran{else} statements and blocks may be omitted.
    \item If \lstfortran{else} is missing and none of the logical expressions are true, the \lstfortran{if-then-else} construct has no effect.
    \item The \lstfortran{end if} statement must not be omitted.
    \item The \lstfortran{if-then-else} construct can be nested and named.
  \end{itemize}
%  \framebreak
  \begin{columns}
    \column{6cm}
    \vspace{-0.5cm}
    \begin{block}{\scriptsize no \bftt{else if}}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
[outer_name:] if ( expression ) then
  executable statements
else
  executable statements
  [inner_name:] if ( expression ) then
    executable statements
  end if [inner_name]
end if [outer_name]
      \end{lstlisting}
    \end{block}
    \column{5cm}
    \vspace{-0.5cm}
    \begin{block}{\scriptsize no \bftt{else}}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( expression ) then
  executable statements
else if ( expression ) then
  executable statements
else if ( expression ) then
  executable statements
end if
      \end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}

\subsection{Switches}
\begin{frame}[fragile,allowframebreaks]{Case Construct}
  \begin{itemize}
    \item The \lstfortran{case} construct permits selection of one of a number of different block of instructions.
    \item The value of the expression in the \lstfortran{select case} should be an integer or a character string.
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[case_name:] select case ( expression )
  case ( selector )
    executable statement
  case ( selector )
    executable statement
  case default
    executable statement
end select [case_name]
      \end{lstlisting}
    \item The \lstfortran{selector} in each \lstfortran{case} statement is a list of items, where each item is either a single constant or a range of the same type as the expression in the \lstfortran{select case} statement.
    \item A range is two constants separated by a colon and stands for all the values between and including the two values. 
    \item The \lstfortran{case default} statement and its block are optional.
    \item The \lstfortran{select case} statement is executed as follows:
    \begin{enumerate}
      \item Compare the value of expression with the case selector in each case. If a match is found, execute the following block of statements.
      \item If no match is found and a \lstfortran{case default} exists, then execute those block of statements.
    \end{enumerate}
  \end{itemize}
  \begin{ablock}{Notes}
    \begin{itemize}
      \item The values in selector must be unique.
      \item Use \lstfortran{case default} when possible, since it ensures that there is something to do in case of error or if no match is found.
      \item \lstfortran{case default} can be anywhere in the \lstfortran{select case} construct. The preferred location is the last location in the \lstfortran{case} list.
    \end{itemize}
  \end{ablock}
  \framebreak
  \begin{itemize}
    \item Example for character case selector
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
select case ( traffic_light )
  case ( "red" )
    print *, "Stop"
  case ( "yellow" )
    print *, "Caution"
  case ( "green" )
    print *, "Go"
  case default
    print *, "Illegal value: ", traffic_light
end select 
      \end{lstlisting}
    \item Example for integer case selector
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
select case ( score )
  case ( 50 : 59 )
    GRADE = "D"
  case ( 60 : 69 )
    GRADE = "C"
  case ( 70 : 79 )
    GRADE = "B"
  case ( 80 : ) 
    GRADE = "A"
  case default
    GRADE = "F"
end select
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}{Exercise}
  \begin{itemize}
  \item Solve the quadratic equation $ax^2 + bx + c = 0$
  \end{itemize}
    \begin{equation*}
      x = \frac{-b \pm \sqrt(b^2 - 4ac)}{2a}
    \end{equation*}
  \begin{algorithm}[H]
    \caption{Pseudo Code for Solving Quadratic Equation}
    \begin{algorithmic}
      \Program{roots}{}
      \State read a, b, c from standard input
      \State $d \gets b^2 + 4ac$
%      \If {$d > 0$ }
      \State $x \gets (-b + \sqrt{d})/2a$ and $x \gets (-b -\sqrt{d})/2a$
%      \EndIf
      \EndProgram{roots}
    \end{algorithmic}
  \end{algorithm}
\end{frame}
  
\subsection{Loops}
\begin{frame}[fragile,allowframebreaks]{Do Construct}
  \begin{itemize}
    \item The looping construct in fortran is the \lstfortran{do} construct.
    \item The block of statements called the loop body or \lstfortran{do} construct body is executed repeatedly as indicated by loop control.
    \item A \lstfortran{do} construct may have a construct name on its first statement
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do loop_control
  execution statements
end do [do_name]
      \end{lstlisting}
    \item There are two types of loop control:
    \begin{enumerate}
      \item Counting: a variable takes on a progression of integer values until some limit is reached.
      \begin{itemize}
        \item[$\vardiamond$] \textit{variable = start, end[, stride] }
        \item[$\vardiamond$] \textit{stride} may be positive or negative integer, default is 1 which can be omitted.
      \end{itemize}
      \item General: a loop control is missing
    \end{enumerate}
    \item Before a \lstfortran{do} loop starts, the expression \textit{start, end} and \textit{stride} are evaluated. These values are not re-evaluated during the execution of the \lstfortran{do} loop.
    \item \textit{stride} cannot be zero.
    \item If \textit{stride} is positive, this \lstfortran{do} counts up.
    \begin{enumerate}
      \scriptsize
      \item The \textit{variable} is set to \textit{start}
      \item If \textit{variable} is less than or equal to \textit{end}, the block of statements is executed.
      \item Then, \textit{stride} is added to \textit{variable} and the new \textit{variable} is compared to \textit{end}
      \item If the value of \textit{variable} is greater than \textit{end}, the \lstfortran{do} loop completes, else repeat steps 2 and 3
    \end{enumerate}
    \item If \textit{stride} is negative, this \lstfortran{do} counts down.
    \begin{enumerate}
      \scriptsize
      \item The \textit{variable} is set to \textit{start}
      \item If \textit{variable} is greater than or equal to \textit{end}, the block of statements is executed.
      \item Then, \textit{stride} is added to \textit{variable} and the new \textit{variable} is compared to \textit{end}
      \item If the value of \textit{variable} is less than \textit{end}, the \lstfortran{do} loop completes, else repeat steps 2 and 3
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Do Construct: Nested}
  \begin{itemize}
    \item The \lstfortran{exit} statement causes termination of execution of a loop. 
    \item If the keyword \lstfortran{exit} is followed by the name of a do construct, that named loop (and all active loops nested within it) is exited and statements following the named loop is executed.
    \item The \lstfortran{cycle } statement causes termination of the execution of \textit{one iteration} of a loop.
    \item[] The \lstfortran{do} body is terminated, the \lstfortran{do} variable (if present) is updated, and control is transferred back to the beginning of the block of statements that comprise the \lstfortran{do} body. 
    \item If the keyword \lstfortran{cycle} is followed by the name of a construct, all active loops nested within that named loop are exited and control is transferred back to the beginning of the block of statements that comprise the named \lstfortran{do} construct.
  \end{itemize}
  \framebreak
  \begin{columns}[t]
    \column{5.5cm}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{Exercise/nested.f90}
    \column{5.5cm}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./nested 
     0     0    0.000000    0.000000    0.000000
     0    45    0.000000    0.785398    0.000000
     0   135    0.000000    2.356194   -0.000000
     0   180    0.000000    3.141593   -0.000000
    45     0    0.785398    0.000000    0.707107
    45    45    0.785398    0.785398    1.000000
    45   135    0.785398    2.356194   -1.000000
    45   180    0.785398    3.141593   -0.707107
    90     0    1.570796    0.000000    1.000000
    90    45    1.570796    0.785398    1.414214
    90   135    1.570796    2.356194   -1.414214
    90   180    1.570796    3.141593   -1.000000
   135     0    2.356194    0.000000    0.707107
   135    45    2.356194    0.785398    1.000000
   135   135    2.356194    2.356194   -1.000000
   135   180    2.356194    3.141593   -0.707107
   180     0    3.141593    0.000000    0.000000
   180    45    3.141593    0.785398    0.000000
   180   135    3.141593    2.356194   -0.000000
   180   180    3.141593    3.141593   -0.000000
    \end{Verbatim}
  \end{columns}
\end{frame}


\begin{frame}[fragile]{Do Construct: General}
  \begin{itemize}
    \item The General form of a \lstfortran{do} construct is
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do
  executable statements
end do [do_name]
      \end{lstlisting}
    \item The \lstfortran{executable statements} will be executed indefinitly.
    \item To exit the \lstfortran{do} loop, use the \lstfortran{exit} or \lstfortran{cycle} statement.
    \item The \lstfortran{exit} statement causes termination of execution of a loop.
    \item The \lstfortran{cycle } statement causes termination of the execution of \textit{one iteration} of a loop.
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
    cycle finite
  end if inner
  if ( i > 100 ) exit finite
end do finite
      \end{lstlisting}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Do While Construct}
  \begin{itemize}
    \item If a condition is to be tested at the top of a loop, a \lstfortran{do ... while } loop can be used
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do while ( expression )
  executable statements
end do [do_name]
      \end{lstlisting}
    \item The loop only executes if the logical expression evaluates to \lstfortran{.true.}
  \end{itemize}
  \begin{columns}[t]
    \column{0.4\textwidth}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do while ( i <= 100 )
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
  end if inner
end do finite
    \end{lstlisting}
    \column{0.4\textwidth}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
    cycle finite
  end if inner
  if ( i > 100 ) exit finite
end do finite
    \end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}[allowframebreaks]{Exercise}
  \begin{itemize}
  \item In mathematical terms, the sequence $F_n$ of Fibonacci numbers is defined by the recurrence relation
    \begin{equation*}
      F_n = F_{n-1} + F_{n-2},
    \end{equation*}
    with seed values
    \begin{equation*}
      F_0 = 0 ;  F_1 = 1.
    \end{equation*}
  \item Calculate the first $n$ Fibonacci Numbers.
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code to calculate sequence of Fibinacci Numbers}
    \begin{algorithmic}
      \Program{Fibonacci}{}
      \State $n \gets$ a number $> 5$
      \State $f0 \gets 0$, $f1 \gets 1$
      \Do {$i \gets 2 \cdots n $}
      \State {$fn \gets f0 + f1$}, {$f0 \gets f1$}, {$fn \gets f1$}
      \EndDo
      \EndProgram{Fibonacci}
    \end{algorithmic}
  \end{algorithm}

  \framebreak

  \begin{itemize}
  \item Calculate factorial and double factorial of a number
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code for Factorial}
    \begin{algorithmic}
      \Program{Factorial}{}
      \State $n \gets$ a number
      \Do {$i \gets n, n-1, n-2 \cdots 1$}
      \State $f = f * i$
      \EndDo
      \EndProgram{Factorial}
    \end{algorithmic}
  \end{algorithm}

  \framebreak
  
  \begin{itemize}
  \item In mathematics, the greatest common divisor (gcd) of two or more integers, when at least one of them is not zero, is the largest positive integer that divides the numbers without a remainder.
  \item Using Euclid's algorithm
    \begin{align*}
      gcd(a,0) &= a \\
      gcd(a,b) &= gcd(b, a\% b)
    \end{align*}
  \item In arithmetic and number theory, the least common multiple of two integers a and b is the smallest positive integer that is divisible by both a and b.
    \begin{equation*}
      lcm(a,b) = \frac{\mid{}a\cdot{}b\mid}{gcd(a,b)}
    \end{equation*}
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code to calculate gcd}
    \begin{algorithmic}
      \Program{gcdlcm}{}
      \State $a,b \gets$ two integers
      \Do{\textbf{while} $b \ne 0$}
      \State $t\gets v$, $v\gets u\%v$, $u\gets t$
      \EndDo
      \State $gcd \gets |u|$
      \State $lcm \gets |a\cdot{}b|/gcd$
      \EndProgram{gcdlcm}
    \end{algorithmic}
  \end{algorithm}

  \framebreak
  \begin{itemize}\item {Calculate pi by Numerical Integration} \end{itemize}
  \begin{columns}
    \column{5cm}
    \begin{itemize}
    \item We know that
      \begin{align*}
        \int^1_0 \dfrac{4.0}{(1+x^2)}\, dx = \pi
      \end{align*}
    \item So numerically, we can approxiate pi as the sum of a number of rectangles
      \begin{align*}
        \sum^N_{i=0}\,F(x_i)\Delta x \approx \pi
      \end{align*}
    \item[] \fontsize{4}{5}{ Meadows et al, A ``hands-on'' introduction to OpenMP, SC09 }
    \end{itemize}
    \column{5cm}
    \begin{center}
      \includegraphics[width=4cm]{./graphics/pi}
    \end{center}
  \end{columns}
  
  \begin{algorithm}[H]
    \caption{Pseudo Code for Calculating Pi}
    \begin{algorithmic}
      \Function{calculate\_pi}{}
      \State $step \gets 1/n$
      \State $sum \gets 0$
      \Do{$i \gets 0\cdots n$}
      \State $x \gets (i+0.5)*step; sum \gets sum + 4/(1+x^2)$
      \EndDo
      \State $pi \gets sum * step$
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
\end{frame}


\section{Input and Output}
\begin{frame}[fragile,allowframebreaks]
  \frametitle{Input and Output Descriptors}
  \begin{itemize}
    \item Input and output are accomplished by operations on files.
    \item Files are identified by some form of file handle, in Fortran called the \textbf{unit number}.
    \item We have already encountered read and write command such as \lstfortran{print *,} and \lstfortran{read *,}
    \item Alternative commands for read and write are 
    \item[] \lstfortran{read(unit,*)}
    \item[] \lstfortran{write(unit,*)}
    \item There is no comma after the ')'. FORTRAN allowed statements of the form \lstfortran{write(unit,*),} which is not supported on some compilers such as IBM XLF. Please avoid this notation in FORTRAN programs.
    \item The default unit number 5 is associated with the standard input, and
    \item unit number 6 is assigned to standard output.
    \item You can replace \lstfortran{unit} with $\star$ in which case standard input (5) and output (6) file descriptors are used.
    \item The second $\star$ in \lstfortran{read/write} or the one in the \lstfortran{print */read *} corresponds to unformatted input/output.
    \item If I/O is formatted, then $\star$ is replaced with
    \item[]\lstfortran{fmt=<format specifier>}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{File Operations}
  \begin{itemize}
    \item A file may be opened with the statement
    \item[]\lstfortran{OPEN([UNIT=]un, FILE=fname [, options])}
    \item Commonly used options for the open statement are:
    \item[]\lstfortran{IOSTAT=ios}: This option returns an integer ios; its value is zero if the statement executed without error, and nonzero if an error occured.
    \item[]\lstfortran{ERR=label}: label is the label of a statement in the same program unit. In the event of an error, execution is transferred to this labelled statement. 
    \item[]\lstfortran{STATUS=istat}: This option indicates the type of file to be opened. Possible values are:
      \begin{itemize}
        \item[old]: the file specified by the file parameter must exist. 
        \item[new]: the file will be created and must not exist. 
        \item[replace]: the file will be created if it does not exist or if it exists, the file will be deleted and created i.e. contents overwritten.
        \item[unknown]: the file will be created if it doesn't exist or opened if it exists without further processing.
        \item[scratch]: file will exist until the termination of the executing program or until a \lstfortran{close} is executed on that unit.
      \end{itemize}
    \item[] \lstfortran{position=todo}: This options specifies the position where the read/write marker should be placed when opened. Possible values are:
      \begin{itemize}
        \item[rewind]: positions the file at its initial point. Convenient for rereading data from file such as input parameters.
        \item[append]: positions the file just before the endfile record. Convenient while writing to a file that already exists. If the file is \texttt{new}, then the position is at its initial point.
      \end{itemize}
      \framebreak
    \item The status of a file may be tested at any point in a program by means of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{INQUIRE([UNIT=]un, options)}
    \item[OR]
    \item[] \lstfortran{INQUIRE(FILE=fname, options)}
    \item At least one option must be specified. Options include
    \item[] \lstfortran{IOSTAT=ios}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{EXIST=lex}: Returns whether the file exists in the logical variable \lstfortran{lex}
    \item[] \lstfortran{OPENED=Iop}: Returns whether the file is open in the logical variable \lstfortran{Iop}
    \item[] \lstfortran{NUMBER=num}: Returns the unit number associated with the file, or -1 if no number is assigned to it. Generally used with the second form of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{NAMED=isnamed}: Returns whether the file has a name. Generally used with the first form of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{NAME=fname}: Returns the name of the file in the character variable \lstfortran{fname}. Used in conjunction with the \lstfortran{NAMED} option.
    \item[] \lstfortran{READ=rd}: Returns a string \lstfortran{YES, NO}, or \lstfortran{UNKNOWN} to the character variable \lstfortran{rd} depending on whether the file is readable. If status cannot be determined, it returns \lstfortran{UNKNOWN}.
    \item[] \lstfortran{WRITE=wrt}: Similar to the \lstfortran{READ} option to test if a file is writable.
    \item[] \lstfortran{READWRITE=rdwrt}: Similar to the \lstfortran{READ} option to test if a file is both readable and writeable.
      \framebreak
    \item A file may be closed with the statement
    \item[]\lstfortran{CLOSE([UNIT=]un [, options])}
    \item Commonly used options for the close statement are:
    \item[] \lstfortran{IOSTAT=ios}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{ERR=label}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{STATUS=todo}: What actions needs to be performed on the file while closing it. Possible values are
      \begin{itemize}
        \item[keep]: file will continue to exist after the close statement, default option except for scratch files.
        \item[delete]: file will cease to exist after the close statement, default option for scratch files.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Reading and Writing Data}
  \begin{itemize}
    \item The \lstfortran{WRITE} statement is used to write to a file.
    \item Syntax for writing a list of variable, \lstfortran{varlist}, to a file associated with unit number \lstfortran{un} 
    \item[] \lstfortran{WRITE(un, options) varlist}
    \item The most common options for \lstfortran{WRITE} are:
    \item[] \lstfortran{FMT=label} A format statement label specifier.
    \item[] You can also specify the exact format to write the data to be discussed in a few slides.
    \item[] \lstfortran{IOSTAT=ios} Returns an integer indicating success or failure; zero if statement executed with no erros and nonzero if an error occured.
    \item[] \lstfortran{ERR=label} The label is a statement label to which the program should jump if an error occurs.
    \item The \lstfortran{READ} statement is used to read from a file.
    \item Syntax for reading a list of variable, \lstfortran{varlist}, to a file associated with unit number \lstfortran{un}
    \item[] \lstinline[language={[90]Fortran}]|READ(un, options) varlist|
    \item Options to the \lstfortran{READ} statement are the same as that of the \lstfortran{WRITE} statement with one additional option,
    \item[] \lstfortran{END=label} The label is a statement label to which the program should jump if the end of file is detected.
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{List-Directed I/O}
  \begin{itemize}
    \item The simplest method of getting data into and out of a program is list-directed I/O.
    \item The data is read or written as a stream into or from specified variables either from standard input or output or from a file.
    \item The unit number associate with standard input is 5 while standard output is 6.
    \item If data is read/written from/to standard input/output, then
      \begin{itemize}
        \item the unit number, \lstfortran{un} can also be replaced with $\ast$,
        \item use alternate form for reading and writing i.e. the \lstfortran{read *,} and \lstfortran{print *,} covered in an earlier slide.
        \item If data is unformatted i.e. plain ASCII characters, the option to \lstfortran{write} and \lstfortran{read} command is $\ast$
      \end{itemize}
    \item Example of list-directed output to standard output or to a file associated with unit number 8
      \begin{lstlisting}[language={[90]Fortran}]
  print *, a, b, c, arr
  write(*,*) a, b, arr
  write(6,*) a, b, c, arr
  write(8,*) a, b, c, &
    arr
      \end{lstlisting}
    \item Unlike C/C++, Fortran always writes an end-of-line marker at the end of the list of item for any \lstfortran{print} or \lstfortran{write} statements.
    \item Printing a long line with many variables may thus require continuations.
    \item Example of list-directed input from standard output or to a file associated with unit number 8
      \begin{lstlisting}[language={[90]Fortran}]
  read *, a, b, c, arr
  read(*,*) a, b, c, arr
  read(5,*) a, b, c, arr
  read(8,*) a, b, c, arr
      \end{lstlisting}
    \item When reading from standard input, the program will wait for a response from the console.
    \item Unless explicitly told to do so, no prompts to enter data will be printed. Very often programmers use a print statement to let you know that a response is expected.
      \begin{lstlisting}[language={[90]Fortran}]
 print *, 'Please enter a value for the variable inp'
 read *, inp
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Formatted Input/Output}
  \begin{itemize}
    \item List-directed I/O does not always print the results in a particularly readable form.
    \item For example, a long list of variable printed to a file or console may be broken up into multiple lines.
    \item In such cases it is desirable to have more control over the format of the data to be read or written.
    \item Formatted I/O requires that the programmer control the layout of the data.
    \item The type of data and the number of characters that each element may occupy must be specified.
      \framebreak
    \item A formatted data description must adhere to the generic form,
    \item[] \lstfortran{nCw.d}
    \item[] where
      \begin{itemize}
        \item \lstfortran{n} is an integer constant that specifies the number of repititions (default 1 can be omitted),
        \item \lstfortran{C} is a letter indicating the type of the data variable to be written or read,
        \item \lstfortran{w} is the total number of spaces allocated to this variable, and,
        \item \lstfortran{d} is the number of spaces allocated to the fractional part of the variable. Integers are padded with zeros for a total width of \lstfortran{w} provided $d\le w$.
        \item The decimal (.) and \lstfortran{d} designator are not used for integers, characters or logical data types. Note that \lstfortran{d} designator has a different meaning for integers and is usually referred to as \lstfortran{m} to avoid confusion.
      \end{itemize}
    \item Collectively, these designators are called \textbf{edit descriptors}.
    \item The space occupied by an item of data or variable is called \textit{field}.
  \end{itemize}
  \begin{minipage}{\textwidth}
    \begin{center}
      \scriptsize
      \begin{tabular}{abbf}
        \rowcolor{lublue}Data Type & Edit Descriptor & Examples & Result\\
        Integer & nIw[.m] & I5.5 & \lstinline[showspaces=true]|00010|\\
        Real\footnote{\tiny For complex variables, use two appropriate real edit descriptors } (floating point) & nFw.d & F12.6 & \lstinline[showspaces=true]|   10.123456|\\
        Real (exponential) & Ew.d[en]\footnote{\tiny en is used when you need more than 2 digits in the exponent as in 100. E15.7e4 to represent $2.3\times10^{1021}$} & E15.8 & \lstinline[showspaces=true]|   0.12345678E1| \\
        Real (engineering) &  ESw.d\footnote{\tiny data is printed in multiples of 1000} & ES12.3 & \lstinline[showspaces=true]|   50.123E-3| \\
        Character & nAw & A12 & \lstinline[showspaces=true]|     Fortran| \\
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{itemize}
    \item \textbf{Control descriptors} alter the input or output by addings blanks, new lines and tabs.
  \end{itemize}
  \begin{center}
    \scriptsize
    \begin{tabular}{ccl}
      \rowcolor{lulime}Space & \texttt{n}X & add \texttt{n} spaces \\
      \rowcolor{lulime!50} & t\texttt{n} & tab to position \texttt{n} \\
      \rowcolor{lulime!50} Tabs & tl\texttt{n} & tab left \texttt{n} positions \\
      \rowcolor{lulime!50} & tr\texttt{n} & tab right \texttt{n} positions \\
      \rowcolor{lulime}New Line & / & Create a new line record \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Format Statements}
  \begin{itemize}
    \item Edit descriptors must be used in conjunction with a \lstfortran{PRINT}, \lstfortran{WRITE} or \lstfortran{READ} statement.
    \item In the simplest form, the format is enclosed in single quotes and parentheses as as argument to the keyword.
      \begin{lstlisting}[language={[90]Fortran}]
 print '(I5,5F12.6)', i, a, b, c, z ! complex z
 write(6,'(2E15.8)') arr1, arr2
 read(5,'(2a)') firstname, lastname
      \end{lstlisting}
      \item If the same format is to be used repeatedly or it is complicated, the \lstfortran{FORMAT} statement can be used.
      \item The \lstfortran{FORMAT} statement must be labeled and the label is used in the input/output statement to reference it
        \begin{lstlisting}[language={[90]Fortran}]
 label FORMAT(formlist)
 PRINT label, varlist
 WRITE(un, label) varlist
 READ(un, label) varlist
        \end{lstlisting}
      \item The \lstfortran{FORMAT} statements can occur anywhere in the same program unit. Most programmers list all \lstfortran{FORMAT} statements immediately after the type declarations before any executable statements.
        \begin{lstlisting}[language={[90]Fortran}]
 10 FORMAT(I5,5F12.6)
 20 FORMAT(2E15.8)
 100 FORMAT(2a)
 
 print 10, i, a, b, c, z ! complex z
 write(6,20) arr1, arr2
 read(5,100) firstname, lastname
        \end{lstlisting}
  \end{itemize}
%  \lstinline[language={[90]Fortran}]|print '(20X,I5,20X,I5/21X,I4,21X,I4)', N, M, I, J|
%  \lstinline[showspaces=true]|                    12345                    12345|
%  \lstinline[showspaces=true]|                     1234                     1234| 
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Namelist}
  \begin{itemize}
    \item Many scientific codes have a large number of input parameters.
    \item Remembering which parameter is which and also the order in which they are to read, make creating input files very tedious.
    \item Fortran provides \lstfortran{NAMELIST} input simplify this situation.
    \item In a \lstfortran{NAMELIST}, parameters are specified by name and value and can appear in any order.
    \item The \lstfortran{NAMELIST} is declared as a non-executable statement in the subprogram that reads the input and the variables that can be specified in it are listed.\\
      \lstfortran{NAMELIST /name/ varlist}
    \item Namelists are read with a special form of the \lstfortran{READ} statement.\\
      \lstfortran{READ(un,[nml=]name)}
      \framebreak
    \item The input file must follow a particular format:
      \begin{itemize}
        \item begin with an ampersand followed by the name of the namelist (\&name) and ends with a slash (/),
        \item variables are specified with an equals sign (=) between the variable name and its value,
        \item only statis objects may be part of a namelist; i.e. dynamically allocated arrays, pointers and the like are not permitted
      \end{itemize}
    \item For example, consider a program that declares a namelist as follows:\\
      \lstfortran{namelist/moldyn/natom,npartdim,tempK,nstep,dt}
    \item The corresponding input file can take the form
      \lstinputlisting{./Exercise/MolDyn/orig/md.inp}
    \item Note:
      \begin{itemize}
        \item parameters may appear in any order in the input file, and
        \item may be omitted if they are not needed i.e. they can take default values that is specified in the program
      \end{itemize}
    \item The above namelist can be read with a single statement as in (other options to \lstfortran{READ} statement can be added if needed)\\
      \lstfortran{READ(10, nml=moldyn)}
    \item To write the values of a namelist is similar\\
      \lstfortran{WRITE(20, nml=moldyn)}
    \item Namelist names and variables are case insensitive.
    \item The namelist designator cannot have blanks
    \item Arrays may be namelist variables, but all the values of the array must be listed after the equals sign following its name
    \item If any variable name is repeated, the final value is taken.
    \item Namelist are convenient when you want to read different input for different types of calculations within the same program.
    \item Amber Molecular Dynamics package uses namelist to read input. The following is the input file from Amber's test directory.
      \begin{lstlisting}
 &cntrl 
   ntx=1, imin=5, ipb=1, inp=2, ntb=0,  
 /      
 &pb
   npbverb=0, istrng=0, epsout=80.0, epsin=1.0, space=0.5,  
   accept=0.001, sprob=1.6, radiopt=1, dprob=1.6,   
 /      
      \end{lstlisting}
    \item If multiple variables are listed on the same line, they need to be separated by a comma (,) not semicolon(;)
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Internal Read and Write}
  \begin{itemize}
    \item Fortran allows a programmer to cast numeric types to character type and vice versa.
    \item The character variable functions as an internal file.
    \item An \textbf{internal write} converts from numeric to character type, while
    \item an \textbf{internal read} converts from character to numeric type.
    \item This is useful feature particularly for writing output of arrays that are dynamically allocated.
    \item Example: Convert an integer to a character
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=10) :: num
 INTEGER           :: inum
 WRITE(NUM,'(A10)') inum
      \end{lstlisting}
      \framebreak
    \item Example: Convert an character to an integer
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=10) :: num = "435"
 INTEGER   :: inum
 READ(inum,'(I4)') num
      \end{lstlisting}
    \item Example: Writing data when parameters are not known at compile time
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=23) :: xx
 CHARACTER(len=13) :: outfile
 INTEGER  :: natoms, istep
 REAL     :: time
 REAL, ALLOCATABLE, DIMENSION(:) :: coords

 natoms = 100 ; ALLOCATE(coords(natoms*3))

 WRITE(xx,'(A,I5,A)') '(F12.6,', 3*natoms, '(2X,E15.8))'
 WRITE(outfile,'(A8,I5.5,A4)') 'myoutput', istep, '.dat'

 OPEN(unit = 10, file = outfile)
 WRITE(10, xx) time, coords(:)
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}{End of Day 1}
  \begin{itemize}
    \item Thats all for Day 1
    \item Any Question?
    \item In the second part of the tutorial we will cover advanced topics:
      \begin{enumerate}
        \item Arrays: Dynamic Arrays, Array Conformation concepts, Array declarations and Operations, etc.
        \item Procedures: Modules, Subroutines, Functions, etc.
        \item Object Oriented Concepts: Derived Type Data, Generic Procedures and Operator Overloading.
      \end{enumerate}
  \end{itemize}
\end{frame}
\begin{frame}{References}
  \begin{itemize}
    \item Fortran 95/2003 Explained, Michael Metcalf
    \item Modern Fortran Explaned, Michael Metcalf
    \item Guide to Fortran 2003 Programming, Walter S. Brainerd
    \item Introduction to Programming with Fortran: with coverage of Fortran 90, 95, 2003 and 77, I. D. Chivers
    \item Fortran 90 course at University of Liverpool, \url{http://www.liv.ac.uk/HPC/F90page.html}
    \item Introduction to Modern Fortran, University of Cambridge, \url{http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Fortran}
    \item Scientific Programming in Fortran 2003: A tutorial Including Object-Oriented Programming, Katherine Holcomb, University of Virginia.
  \end{itemize}
\end{frame}

\section{Exercise}
\begin{frame}{SAXPY}
  \begin{itemize}
    \item SAXPY is a common operation in computations with vector processors included as part of the BLAS routines
    \item[] $y\leftarrow \alpha x + y$
%    \item SAXPY is a combination of scalar multiplication and vector addition
    \item Write a SAXPY code to multiply a vector with a scalar.
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code for SAXPY}
    \begin{algorithmic}
      \Program{saxpy}{}
      \State $n \gets$ some large number
      \State $x(1:n) \gets$ some number say, 1
      \State $y(1:n) \gets$ some other number say, 2
      \State $a \gets$ some other number ,say, 3
      \Do{$i \gets 1\cdots n$}
      \State $y_i \gets y_i + a * x_i$
      \EndDo
      \EndProgram{saxpy}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

\begin{frame}[allowframebreaks]{Matrix Multiplication}
  \begin{itemize}
    \item Most Computational code involve matrix operations such as matrix multiplication.
    \item Consider a matrix {\bf C} which is a product of two matrices {\bf A} and {\bf B}:
    \item[] Element {\it i,j} of {\bf C} is the dot product of the $i^{th}$ row of {\bf A} and $j^{th}$ column of {\bf B}
    \item Write a MATMUL code to multiple two matrices.
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{./graphics/matmul}
  \end{center}

  \begin{algorithm}[H]
    \caption{Pseudo Code for MATMUL}
    \begin{algorithmic}
      \Program{matmul}{}
      \State $m,n \gets$ some\,large\,number $\le 1000$
      \State Define $a_{mn}, b_{nm}, c_{mm}$
      \State $a_{ij} \gets i+j; b_{ij} \gets i-j; c_{ij} \gets 0$
      \Do{$i \gets 1\cdots m$}
      \Do{$j \gets 1\cdots m$}
      \State $c_{i,j} \gets \sum^{n}_{k=1} a_{i,k}*b_{k,j}$
      \EndDo
      \EndDo
      \EndProgram{matmul}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

%\begin{frame}[allowframebreaks]{Molecular Dynamics}
%  \begin{itemize}
%    \item Molecular dynamics (MD) is a computer simulation of physical movements of atoms and molecules in the context of N-body simulation.
%    \item The atoms and molecules are allowed to interact for a period of time, giving a view of the motion of the atoms described by Newton's Law of Motion.
%    \item A simple MD code is classic example for understanding various concepts of Modern Fortran.
%    \item Take the code md-orig.f90 and modify it using the concepts learned. This exercise is designed for the second day of the tutorials wherein you can modify the code using various concepts covered viz,
%      \begin{enumerate}
%        \item Dynamical Allocation of Arrays,
%        \item Array operations,
%        \item Modules, subroutines and functions,
%        \item Derived Types,
%        \item Object Oriented Concepts such as subroutine, function and operator overloading.
%      \end{enumerate}
%    \item You do not need to start working on this on the first day but getting familiar with the code is a good start for now.
%  \end{itemize}
%\end{frame}

\end{document}

