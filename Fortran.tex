\documentclass[c,mathserif,compress,xcolor=svgnames]{beamer} 
\mode<presentation>
{  
  \setbeamertemplate{background canvas}[vertical shading][bottom=blue!5,top=blue!5]
  \setbeamertemplate{navigation symbols}{}%{\insertsectionnavigationsymbol}
  \usetheme{LSU}
}

\usefonttheme{professionalfonts}
\usefonttheme{serif}

\usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{amsmath,amssymb,amsfonts,subfigure,pifont}
\usepackage{multirow,multicol}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{algorithm,algpseudocode}
\usepackage{etex}
\usepackage{fancyvrb,listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82} 
\lstset{%
language=bash,                % the language of the code
%basicstyle=\footnotesize,           % the size of the fonts that are used for the code
basicstyle=\fontsize{4.5}{5.5}\selectfont\ttfamily,
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
%frame=single,                   % adds a frame around the code
%rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
tabsize=2,                      % sets default tabsize to 2 spaces
%captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title=\lstname,                   % show the filename of files included with \lstinputlisting;
% also try caption instead of title
keywordstyle=\color{blue},          % keyword style
commentstyle=\color{dkgreen},       % comment style
stringstyle=\color{mauve},         % string literal style
escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
morekeywords={*,\dots,elif},              % if you want to add more keywords to the set
deletekeywords={\dots},              % if you want to delete keywords from the given language
%morecomment=[l]{//}
}
\lstset{%
language=csh,                % the language of the code
%basicstyle=\footnotesize,           % the size of the fonts that are used for the code
basicstyle=\fontsize{4.5}{5.5}\selectfont\ttfamily,
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
%frame=single,                   % adds a frame around the code
%rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%title=\lstname,                   % show the filename of files included with \lstinputlisting;
% also try caption instead of title
keywordstyle=\color{blue},          % keyword style
commentstyle=\color{dkgreen},       % comment style
stringstyle=\color{mauve},         % string literal style
escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
morekeywords={*,\dots,elif},              % if you want to add more keywords to the set
deletekeywords={\dots},              % if you want to delete keywords from the given language
%morecomment=[l]{//}
}
\lstdefinestyle{LINUX}
{
%    backgroundcolor=\color{black},
%    basicstyle=\tiny\ttfamily,
%    keywordsstyle=\color{blue},
%    morekeywords={Tutorials,BASH,scripts},
%    literate={>}{{\textcolor{blue}{>}}}1
%         {/}{{\textcolor{blue}{/}}}1
%         {./}{{\textcolor{black}{./ }}}1
%         {~}{{\textcolor{blue}{\textasciitilde}}}1,
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\upshape\color{red!90!white},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}
\lstdefinelanguage{OmpFortran}[]{Fortran}{
   rulesepcolor=\color{black},
   %
   extendedchars=true,
   %
   morecomment=[l] [\bfseries\color{red!90!white}]{!\$omp},
   morecomment=[l] [\bfseries\color{red!90!white}]{c\$omp},
   morecomment=[l] [\bfseries\color{red!90!white}]{*\$omp},
   morecomment=[l] [\bfseries\color{red!90!white}]{!\$acc},
   morecomment=[l] [\bfseries\color{red!90!white}]{c\$acc},
   morecomment=[l] [\bfseries\color{red!90!white}]{*\$acc},
}[comments]

\lstdefinelanguage{OmpC}[]{OmpFortran}{
   rulesepcolor=\color{black},
   %
   extendedchars=true,
   %
   morecomment=[l] [\bfseries\color{red!90!white}]{\#pragma\ omp},
   morecomment=[l] [\bfseries\color{red!90!white}]{\#pragma\ acc},
}[comments]

\lstset{escapechar=@,style=customc}
\lstset{literate=%
   *{0}{{{\color{blue}0}}}1
    {1}{{{\color{blue}1}}}1
    {2}{{{\color{blue}2}}}1
    {3}{{{\color{blue}3}}}1
    {4}{{{\color{blue}4}}}1
    {5}{{{\color{blue}5}}}1
    {6}{{{\color{blue}6}}}1
    {7}{{{\color{blue}7}}}1
    {8}{{{\color{blue}8}}}1
    {9}{{{\color{blue}9}}}1
}

\algrenewcommand\algorithmicfunction{\textbf{program}}
\algblockdefx[Program]{Program}{EndProgram}[1]{\textbf{program} \textsc{#1}}[1]{\textbf{end program} \textsc{#1}}
\algloopdefx[doloop]{Do}[1]{\textbf{do} #1}
\algcblockdefx[doloop]{If}{Do}{EndDo}
[1]{\textbf{do} #1}{\textbf{end do}}


\usepackage{tikz}
\usetikzlibrary{shapes,arrows,matrix}
\usetikzlibrary{calc}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage[normalem]{ulem}
% \usepackage{movie15} 

\hypersetup{
  pdftitle={Modern Fortran}
  pdfauthor={Alexander B. Pacheco, User Services Consultant, Louisiana State University}
}                                                         
\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\setbeamercovered{dynamic}
\beamersetaveragebackground{DarkBlue!2}
\beamertemplateballitem

\definecolor{DarkGreen}{rgb}{0.0,0.3,0.0}
\definecolor{Blue}{rgb}{0.0,0.0,0.8} 
\definecolor{dodgerblue}{rgb}{0.1,0.1,1.0}
\definecolor{indigo}{rgb}{0.41,0.1,0.0}
\definecolor{seagreen}{rgb}{0.1,1.0,0.1}
\DeclareSymbolFont{extraup}{U}{zavm}{m}{n}
%\DeclareMathSymbol{\vardiamond}{\mathalpha}{extraup}{87}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}
\newcommand{\smark}{\ding{77}}
\newcommand*\vardiamond{\textcolor{tigerspurple}{%
  \ensuremath{\blacklozenge}}}
\newcommand*\up{\textcolor{green}{%
  \ensuremath{\blacktriangle}}}
\newcommand*\down{\textcolor{red}{%
  \ensuremath{\blacktriangledown}}}
\newcommand*\const{\textcolor{darkgray}%
  {\textbf{--}}}
\newcommand*\enter{\tikz[baseline=-0.5ex] \draw[<-] (0,0) -| (0.5,0.1);}
\newcommand{\bftt}[1]{\textbf{\texttt{#1}}}
\newcommand{\lstfortran}[1]{\lstinline[language={[90]Fortran},basicstyle=\footnotesize\ttfamily]|#1|}
\newcommand{\Verblue}[1]{\Verb[formatcom=\color{blue},commandchars=\\\{\}]!#1!}
\newcommand{\Verbindigo}[1]{\Verb[formatcom=\color{indigo},commandchars=\\\{\}]!#1!}

\setbeamercolor{uppercol}{fg=white,bg=red!30!black}%
\setbeamercolor{lowercol}{fg=black,bg=red!15!white}%
\setbeamercolor{uppercol1}{fg=white,bg=blue!30!black}%
\setbeamercolor{lowercol1}{fg=black,bg=blue!15!white}%%
\setbeamercolor{uppercol2}{fg=white,bg=green!30!black}%
\setbeamercolor{lowercol2}{fg=black,bg=green!15!white}%
\newenvironment{colorblock}[4]
{
\setbeamercolor{upperblock}{fg=#1,bg=#2}
\setbeamercolor{lowerblock}{fg=#3,bg=#4}
\begin{beamerboxesrounded}[upper=upperblock,lower=lowerblock,shadow=true]}
{\end{beamerboxesrounded}}
\newenvironment{ablock}[0]
{
\begin{beamerboxesrounded}[upper=uppercol,lower=lowercol,shadow=true]}
{\end{beamerboxesrounded}}
\newenvironment{bblock}[0]
{
\begin{beamerboxesrounded}[upper=uppercol1,lower=lowercol1,shadow=true]}
{\end{beamerboxesrounded}}
\newenvironment{eblock}[0]
{
\begin{beamerboxesrounded}[upper=uppercol2,lower=lowercol2,shadow=true]}
{\end{beamerboxesrounded}}


\title{Modern Fortran}


\author[Alex Pacheco]{\large{Alexander~B.~Pacheco}}
       
%\institute[High Performance Computing @ Louisiana State University - http://www.hpc.lsu.edu] {\inst{}\footnotesize{User Services Consultant\\LSU HPC \& LONI\\sys-help@loni.org}}
\institute[HPC Training: Spring 2014] {\inst{}\footnotesize{User Services Consultant\\LSU HPC \& LONI\\sys-help@loni.org}}

\date[\insertframenumber/\inserttotalframenumber\hfill\hspace{1.5cm}]{\scriptsize{HPC Training Spring 2014\\Louisiana State University\\Baton Rouge\\February 19 \& March 12, 2014}}
     
\subject{Talks}
\keywords{LONI \& LSU HPC Computing Resources, Fortran Programming}
% This is only inserted into the PDF information catalog. Can be left
% out. 




% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% Main Logo on bottom left
\pgfdeclareimage[height=0.5cm]{institute-logo}{its-logo}
\logo{\pgfuseimage{institute-logo}}
% University Logo on top left
\pgfdeclareimage[height=0.55cm]{university-logo}{LSUGeauxPurp}
\tllogo{\pgfuseimage{university-logo}}
% Logo at top right
\pgfdeclareimage[height=0.55cm]{its-logo}{LONI}
\trlogo{\pgfuseimage{its-logo}}
% Logo at bottom right
\pgfdeclareimage[height=0.5cm]{hpc-logo}{cct-logo}
\brlogo{\pgfuseimage{hpc-logo}}

% for the list of parts
\makeatletter
%\AtBeginPart{%
%    \addtocontents{parttoc}{\protect\beamer@partintoc{\the\c@part}{\beamer@partnameshort}{\the\c@page}}%
%    \frame{\partpage}%
%}
\newcommand{\parttableofcontents}{\@starttoc{parttoc}}
\newcommand{\beamer@partintoc}[3]{#2\par}
\makeatother


% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSection[]
% {
%   \begin{frame}<beamer>
%    \frametitle{{Outline}}
%    \scriptsize
%    \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }

\begin{document}

\frame{\titlepage}

%\footnotesize
%\begin{frame}[label=toc,squeeze,allowframebreaks]
%  \scriptsize
%  \frametitle{{Outline}}
%  \tableofcontents
%\end{frame}


\begin{frame}[c]{Tutorial Outline}
  \begin{eblock}{Day 1: Introduction to Fortran Programming}
    \begin{itemize}
      \item[] On the first day, we will provide an introduction to the Fortran 90/95 Programming Language. Go to slide~\ref{day1}
    \end{itemize}
  \end{eblock}
  \begin{eblock}{Day 2: Advanced Concepts in Fortran Programming}
    \begin{itemize}
      \item[] On the second day, we will cover advanced topics such as modules, derived types, interfaces, etc. Go to slide~\ref{day2}
    \end{itemize}
  \end{eblock}
\end{frame}

\part{Introduction to Fortran Programming}
\frame[label=day1]{\partpage}
\begin{frame}{Outline of Part I}
  \tableofcontents[part=1,hideallsubsections]
\end{frame}


\section{Introduction}
\begin{frame}{What is Fortran?}
  \begin{itemize}
    \item Fortran is a general-purpose, imperative programming language that is especially suited to numeric computation and scientific computing.
    \item Originally developed by IBM for scientific and engineering applications.
    \item The name Fortran is derived from The IBM Mathematical \textbf{For}mula \textbf{Tran}slating System.
    \item It was one of the first widely used "high-level" languages, as well as the first programming language to be standardized. 
    \item It is still the premier language for scientific and engineering computing applications.
  \end{itemize}
\end{frame}

\begin{frame}{Many Flavors of Fortran}
  \begin{itemize}
    \item FORTRAN --- first released by IBM in 1956
    \item FORTRAN II --- released by IBM in 1958
    \item FORTRAN IV --- released in 1962, standardized
    \item FORTRAN 66 --- appeared in 1966 as an ANSI standard
    \item FORTRAN 77 --- appeared in 1977, structured features
    \item Fortran 90 --- 1992 ANSI standard, free form, modules
    \item Fortran 95 --- a few extensions
    \item Fortran 2003 --- object oriented programming
    \item Fortran 2008 --- a few extensions
  \end{itemize}
  The correct spelling of Fortran for 1992 ANSI standard and later (sometimes called Modern Fortran) is "Fortran". Older standards are spelled as "FORTRAN". 
\end{frame}

\begin{frame}{Why Learn Fortran?}
  \begin{itemize}
    \item Fortran was designed by, and for, people who wanted raw number crunching speed. 
    \item There's a great deal of legacy code and numerical libraries written in Fortran,
    \item attempts to rewrite that code in a more "stylish" language result in programs that just don't run as fast.
    \item Fortran is the primary language for some of the most intensive supercomputing tasks, such as 
    \begin{itemize}
      \item astronomy, 
      \item weather and climate modeling, 
      \item numerical linear algebra and libraries, 
      \item computational engineering (fluid dynamics), 
      \item computational science (chemistry, biology, physics), 
      \item computational economics, etc.
    \end{itemize}
    \item How many of you are handed down Fortran code that you are expected to further develop?
  \end{itemize}
\end{frame}

\begin{frame}{Why learn Modern Fortran and not FORTRAN?}
  \begin{itemize}
    \item FORTRAN is a fixed source format dating back to the use of punch cards.
    \item The coding style was very restrictive
    \begin{itemize}
      \item Max 72 columns in a line with
      \item first column reserved for comments indicated by a character such as c or *,
      \item the second through fifth columns reserved for statement labels,
      \item the sixth column for continuation indicator, and
      \item columns 7 through 72 for statements.
      \item Variable names can consists of up to 6 alphanumeric characters (a-z,0-9)
    \end{itemize}
    \item Cannot process arrays as a whole, need to do it element by element.
    \item Cannot allocate memory dynamically.
%    \item Modern Fortran compilers are backwards compatible.
%    \item[] i.e. you can call FORTRAN 77 subroutines and functions from newer code without need for complete rewrite.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{FORTRAN 77 Example}
  \begin{eblock}{SAXPY Code}
    \lstinputlisting[language={[77]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./saxpy.f}
  \end{eblock}
\end{frame}

\begin{frame}{Why Learn Modern Fortran?}
  \begin{itemize}
%    \item Free-format source code and many other simple improvements.
%    \item Arrays as first-class objects, whole-array expressions, assignments, and functions.
%    \item Dynamic memory allocation; pointers to allow complex dynamic data structures to be constructed.
%    \item User-defined data types; existing operators can be overloaded (re-defined) or new ones defined.
%    \item The MODULE - a new program unit which can encapsulate data and a related set of procedures (subroutines or functions). Can implement classes and member functions for object-oriented programming.
%    \item New control structures: SELECT CASE, CYCLE, and EXIT so labels and explicit jumps are rarely needed.
%    \item Recursive functions, generic names for procedures, optional arguments, calls with keywords, and many other procedure call options.
    \item Free-format source code with a maximum of 132 characters per line,
    \item Variable names can consists of up to 31 alphanumeric characters (a-z,0-9) and underscores ( \_ ),
    \item Dynamic memory allocation and Ability to operate on arrays (or array sections) as a whole,
%    \item End of Line comments,
    \item generic names for procedures, optional arguments, calls with keywords, and many other procedure call options,
    \item Recursive procedures and Operator overloading,
    \item Structured data or derived types,
    \item Object Oriented Programming.
    \item See \url{http://en.wikipedia.org/wiki/Fortran\#Obsolescence_and_deletions} for obsolete and deleted FORTRAN 77 features in newer standards.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{FORTRAN 90 Example}
  \begin{eblock}{SAXPY Code}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./saxpy.f90}
  \end{eblock}
\end{frame}

\begin{frame}{Major Differences with C}
  \begin{itemize}
    \item \textbf{No standard libraries:} No specific libraries have to be loaded explicitly for I/O and math.
    \item \textbf{Implicit type declaration:} In Fortran, variables of type real and integer may be declared implicitly, based on their first letter. {\em This behaviour is not recommended in Modern Fortran}.
    \item \textbf{Arrays vs Pointers:} Multi-dimension arrays are supported (arrays in C are one-dimensional) and therefore no vector or array of pointers to rows of a matrices have to be constructed.
    \item \textbf{Call by reference:} Parameters in function and subroutine calls are all passed by reference. When a variable from the parameter list is manipulated, the data stored at that address is changed, not the address itself. Therefore there is no reason for referencing and de-referencing of addresses (as commonly seen in C). 
  \end{itemize}
\end{frame}

\section{Basics}
\begin{frame}[fragile,allowframebreaks]{Fortran Source Code}
  \begin{itemize}
    \item Fortran source code is in ASCII text and can be written in any plain-text editor such as vi, emacs, etc.
    \item For readability and visualization use a text editor capable of syntax highlighting and source code indentation.
    \item Fortran source code is case insensitive i.e. PROGRAM is the same as Program.
    \item Using mixed case for statements and variables is not considered a good programming practice. Be considerate to your collaborators who will be modifying the code.
    \item Some Programmers use uppercase letters for Fortran keywords with rest of the code in lowercase while others (like me) only use lower case letters.
    \item Use whatever convention you are comfortable with and be consistent throughout.
    \item The general structure of a Fortran program is as follows
      \begin{lstlisting}[language={[90]Fortran}]
PROGRAM name
   IMPLICIT NONE
   [specification part]
   [execution part]
   [subprogram part]
END PROGRAM name
      \end{lstlisting}
      \begin{enumerate}
        \item A Fortran program starts with the keyword \lstfortran{PROGRAM} followed by program name,
        \item This is followed by the \lstfortran{IMPLICIT NONE} statement (avoid use of implicit type declaration in Fortran 90),
        \item Followed by specification statements for various type declarations,
        \item Followed by the actual execution statements for the program,
        \item Any optional subprogram, and lastly
        \item The \lstfortran{END PROGRAM} statement
      \end{enumerate}
      \framebreak
    \item A Fortran program consists of one or more program units.
      \begin{itemize}
        \item \lstfortran{PROGRAM}
        \item \lstfortran{SUBROUTINE}
        \item \lstfortran{FUNCTION}
        \item \lstfortran{MODULE}
      \end{itemize}
    \item The unit containing the \lstfortran{PROGRAM} attribute is often called the {\em main program} or {\em main}.
    \item The main program should begin with the \lstfortran{PROGRAM} keyword. This is however not required, but it's use if highly recommended.
    \item A Fortran program should contain only one main program i.e. one \lstfortran{PROGRAM} keyword and can contain one or more subprogram units such as \lstfortran{SUBROUTINE}, \lstfortran{FUNCTION} and \lstfortran{MODULE}.
    \item Every program unit, must end with a \lstfortran{END} keyword.
  \end{itemize}
\end{frame}

\begin{frame}{Simple I/O}
  \begin{itemize}
    \item Any program needs to be able to read input and write output to be useful and portable.
    \item In Fortran, the \lstfortran{print} command provides the most simple form of writing to standard output while,
    \item the \lstfortran{read} command provides the most simple form of reading input from standard input
    \item \lstfortran{print *, <var1> [, <var2> [, ... ]]}
    \item \lstfortran{read *, <var1> [, <var2> [, ... ]]}
    \item The $\ast$ indicates that the format of data read/written is unformatted.
    \item In later sections, we will cover how to read/write formatted data and file operations.
    \item variables to be read or written should be separated by a comma (,).
  \end{itemize}
\end{frame}

\begin{frame}{Your first code in Fortran}
  \begin{itemize}
    \item Open a text editor and create a file helloworld.f90 containing the following lines
    \lstinputlisting[language={[90]Fortran}]{./Exercise/helloworld.f90}
    \item The standard extension for Fortran source files is .f90, i.e., the source files are named <name>.f90.
    \item The .f extension implies fixed format source or FORTRAN 77 code.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Compiling Fortran Code}
  \begin{itemize}
    \item To execute a Fortran program, you need to compile it to obtain an executable.
    \item Almost all *NIX system come with GCC compiler installed. You might need to install the Fortran (gfortran) compiler if its not present.
    \item Command to compile a fortran program
    \item[] \lstinline|<compiler> [flags] [-o executable] <source code>|
    \item The [...] is optional. If you do not specify an executable, then the default executable is \lstinline|a.out|
      \begin{Verbatim}[fontsize=\fontsize{7}{8}\selectfont,formatcom=\color{indigo}]
altair:Exercise apacheco$ gfortran helloworld.f90 
altair:Exercise apacheco$ ./a.out 
 Hello World!
      \end{Verbatim}
    \item Other compilers available on our clusters are Intel (ifort), Portland Group (pgf90) and IBM XL (xlf90) compilers.
    \item[] \Verb[fontsize=\fontsize{7}{8}\selectfont,formatcom=\color{indigo}]|ifort -o helloworld helloworld.f90; ./helloworld|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Comments}
  \begin{itemize}
    \item To improve readability of the code, comments should be used liberally.
    \item A comment is identified by an exclamation mark or bang (!), except in a character string.
    \item All characters after ! upto the end of line is a comment.
    \item Comments can be inline and should not have any Fortran statements following it
  \end{itemize}
  \begin{eblock}{}
    \begin{lstlisting}[language={[90]Fortran}]
program hello
! A simple Hello World code
  print *, 'Hello World!' ! Print Hello World to screen

! This is an incorrect comment if you want Hello World to print to screen ! print *, 'Hello World!'
end program hello
    \end{lstlisting}
  \end{eblock}
\end{frame}

\begin{frame}[allowframebreaks]{Variables}
  \begin{itemize}
    \item Variables are the fundamental building blocks of any program.
    \item In Fortran, a variable name may consist of up to 31 alphanumeric characters and underscores, of which the first character must be a letter.
    \item There are no reserved words in Fortran.
    \item However, names must begin with a letter and should not contain a space.
    \item Allowed names: a, compute\_force, qed123
    \item Invalid names: 1a, a thing, \$sign
  \end{itemize}
  \begin{eblock}{Variable Types}
    \begin{itemize}
      \item Fortran provides five intrinsic data types
      \begin{itemize}
        \item[] \lstfortran{INTEGER}: exact whole numbers
        \item[] \lstfortran{REAL}: real, fractional numbers
        \item[] \lstfortran{COMPLEX}: complex, fractional numbers
        \item[] \lstfortran{LOGICAL}: boolean values
        \item[] \lstfortran{CHARACTER}: strings
      \end{itemize}
      \item and allows users to define additional types.
      \item The \lstfortran{REAL} type is a single-precision floating-point number.
      \item The \lstfortran{COMPLEX} type consists of two reals (most compilers also provide a \lstfortran{DOUBLE COMPLEX} type).
      \item FORTRAN also provides \lstfortran{DOUBLE PRECISION} data type for double precision \lstfortran{REAL}. This is obsolete but is still found in several programs.
    \end{itemize}
  \end{eblock}
  \begin{eblock}{Explicit and Implicit Typing}
    \begin{itemize}
      \item For historical reasons, Fortran is capable of implicit typing of variables.
        \begin{gather*}
          \underbrace{ABCDEFGH}_{REAL}\overbrace{IJKLMN}^{INTEGER}\underbrace{OPQRSTUVWXYZ}_{REAL}
        \end{gather*}
      \item You might come across old FORTRAN program containing \lstfortran{IMPLICIT REAL*8(a-h,o-z)} or \lstfortran{IMPLICIT DOUBLE PRECISION (a-h,o-z)}.
      \item It is highly recommended to explicitly declare all variable and avoid implict typing using the statement \lstfortran{IMPLICIT NONE}.
      \item The \lstfortran{IMPLICIT} statement must precede all variable declarations.
    \end{itemize}
  \end{eblock}
\end{frame}
  
\begin{frame}[allowframebreaks]{Literal Constants}
  \begin{itemize}
    \item Constants are literal representation of a type that are specified by a programmer.
    \item In Fortran, different constant formats are required for each type.
    \item[] \lstfortran{Integer}
    \begin{itemize}
      \item Integers are specified by a number without a decimal point,
      \item may contain an optional sign, and
      \item not contain commas
      \item Example
      \item[] \lstfortran{137}
      \item[] \lstfortran{-5678}
      \item[] \lstfortran{900123}
    \end{itemize}
    \framebreak
    \item[] \lstfortran{Real}
    \begin{itemize}
      \item Reals (single precision) may be specified by adding a decimal point, or by using scientific notation with the letter {\em e} indicating the exponent.
      \item Examples
      \item[] \lstfortran{19.}
      \item[] \lstfortran{3.14159}
      \item[] \lstfortran{6.023e23}
      \item Double precision constants must be specified in the expontent notation with the letter {\em d} indicating the exponent
      \item Examples
      \item[] \lstfortran{23d0}
      \item[] \lstfortran{6.626d-34}
      \item[] \lstfortran{-3.14159d0}
    \end{itemize}
    \framebreak
    \item[] \lstfortran{Complex}
    \begin{itemize}
      \item Complex constants consist of two single-precision constants enclosed in parenthesis.
      \item The first constant is the real part; the second is the imaginary part.
      \item Example
      \item[] \lstfortran{(1.0,0.0)}
      \item[] \lstfortran{(-2.7e4,5.0)}
      \item For systems that support double precision complex, the floating point constants must use the {\em d} notation.
      \item[] \lstfortran{(-2.7d-4,5.d0)}
    \end{itemize}
    \item[] \lstfortran{Logical}
    \begin{itemize}
      \item Logical constants can take only the value \lstfortran{.True.} or \lstfortran{.FALSE.} with the periods part of the constant.
    \end{itemize}
    \framebreak
    \item[] \lstfortran{Character}
    \begin{itemize}
      \footnotesize
      \item Character constants are specified by enclosing them in single quotes.
      \item Example
      \item[] \lstfortran{'This is a character constant'}
      \item[] \lstfortran{'The value of pi is 3.1415'}
      \item If an apostrophe is to be part of the constant, it should be represented by a double quote
      \item[] \lstfortran{'All the world''s a stage'}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Variable Declarations}
  \begin{itemize}
    \item Variables must be declared before they can be used.
    \item In Fortran, variable declarations must precede all executable statements.
    \item To declare a variable, preface its name by its type.
    \item[] \lstfortran{TYPE Variable}
    \item A double colon may follow the type.
    \item[] \lstfortran{TYPE[, attributes] :: Variable}
    \item This is the new form and is recommended for all declarations. If attributes need to be added to the type, the double colon format must be used.
    \item A variable can be assigned a value at its declaration.
    \framebreak
    \item \textbf{Numeric Variables:}
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER :: i, j = 2
REAL    :: a, b = 4.d0
COMPLEX :: x, y 
      \end{lstlisting}
    \item In the above examples, the value of j and b are set at compile time and can be changed later.
    \item If you want the assigned value to be constant that cannot change subsequently, add the attribute \lstfortran{PARAMETER}
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER, PARAMETER :: j = 2
REAL, PARAMETER    :: pi = 3.14159265
COMPLEX, PARAMETER :: ci = (0.d0,1.d0)
      \end{lstlisting}
    \item \textbf{Logical:} Logical variables are declared with the \lstfortran{LOGICAL} keyword
      \begin{lstlisting}[language={[90]Fortran}]
LOGICAL  :: l, flag=.true.
      \end{lstlisting}
    \item \textbf{Character:} Character variables are declared with the \lstfortran{CHARACTER} type; the length is supplied via the keyword \lstfortran{LEN}.
    \item The length is the maximum number of characters (including space) that will be stored in the character variable.
    \item If the \lstfortran{LEN} keyword is not specified, then by default \lstfortran{LEN=1} and only the first character is saved in memory. 
      \begin{lstlisting}[language={[90]Fortran}]
CHARACTER         :: ans = 'yes' ! stored as y not yes
CHARACTER(LEN=10) :: a
      \end{lstlisting}
    \item FORTRAN programmers: avoid the use of \lstfortran{CHARACTER*10} notation.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Array Variables}
  \begin{itemize}
    \item Arrays (or matrices) hold a collection of different values at the same time.
    \item Individual elements are accessed by subscripting the array.
    \item Arrays are declared by adding the \lstfortran{DIMENSION} attribute to the variable type declaration which can be integer, real, complex or character.
    \item Usage: \lstfortran{TYPE, DIMENSION(lbound:ubound) :: variable_name}
    \item[] Lower bounds of one can be omitted
      \begin{lstlisting}[language={[90]Fortran}]
INTEGER, DIMENSION(1:106) :: atomic_number
REAL, DIMENSION(3, 0:5, -10:10) :: values
CHARACTER(LEN=3), DIMENSION(12) :: months
      \end{lstlisting}
    \item In Fortran, arrays can have upto seven dimension.
    \item In contrast to C/C++, Fortran arrays are column major.
    \item We'll discuss arrays in more details in the Advanced Concepts Tutorials.
  \end{itemize}
\end{frame}

\begin{frame}{DATA Statments}
  \begin{itemize}
    \item In FORTRAN, a \lstfortran{DATA} statement may be used to initialize a variable or group of variables.
    \item It causes the compiler to load the initial values into the variables at compile time i.e. a nonexecutable statment
    \item General form
    \item[] \lstfortran{DATA varlist /varlist/ [, varlist /varlist/]}
    \item[] Example \lstfortran{DATA a,b,c /1.,2.,3./}
    \item \lstfortran{DATA} statements can be used in Fortran but it is recommended to to eliminate this statement by initializing variables in their declarations.
    \item In Fortran 2003, variables may be initialized with intrinsic functions (some compilers enable this in Fortran 95)
    \item[] \lstfortran{REAL, PARAMETER :: pi = 4.0*atan(1.0)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{KIND Parameter}
  \begin{itemize}
    \item In FORTRAN, types could be specified with the number of bytes to be used for storing the value:
      \begin{itemize}
        \item \lstfortran{real*4} - uses 4 bytes, roughly $\pm10^{-38}$ to $\pm10^{38}$.
        \item \lstfortran{real*8} - uses 8 bytes, roughly $\pm10^{-308}$ to $\pm10^{308}$.
        \item \lstfortran{complex*16} - uses 16 bytes, which is two \lstfortran{real*8} numbers.
      \end{itemize}
    \item Fortran 90 introduced \lstfortran{kind} parameters to parameterize the selection of different possible machine representations for each intrinsic data types.
    \item The \lstfortran{kind} parameter is an integer which is processor dependent.
    \item There are only 2(3) kinds of reals: 4-byte, 8-byte (and 16-byte), respectively known as single, double (and quadruple) precision.
    \item The corresponding \lstfortran{kind} numbers are 4, 8 and 16 (most compilers)
  \end{itemize}
  \begin{minipage}{\textwidth}
    \begin{center}
      \begin{tabular}{|c|c|c|}
        \hline
        KIND & Size (Bytes) & Data Type \\
        \hline
        1 & 1 & integer, logical, character (default) \\
        2 & 2 & integer, logical \\
        4\footnote{\tiny default for all data types except character} & 4 & integer, real, logical, complex \\
        8 & 8 & integer, real, logical, complex \\
        16 & 16 & real, complex \\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{itemize}
    \item You might come across FORTRAN codes with variable declarations using \lstfortran{integer*4}, \lstfortran{real*8} and \lstfortran{complex*16} corresponding to \lstfortran{kind=4} (integer) and \lstfortran{kind=8} (real and complex).
    \item The value of the \lstfortran{kind} parameter is usually not the number of decimal digits of precision or range; on many systems, it is the number of bytes used to represent the value.
    \item The intrinsic functions \lstfortran{selected\_int\_kind} and \lstfortran{selected\_real\_kind} may be used to select an appropriate \lstfortran{kind} for a variable or named constant.
    \item \lstfortran{selected_int_kind(R)} returns the kind value of the smallest integer type that can represent all values ranging from $-10^R$ (exclusive) to $10^R$ (exclusive)
    \item \lstfortran{selected\_real\_kind(P,R)} returns the kind value of a real data type with decimal precision of at least P digits, exponent range of at least R. At least one of P and R must be specified, default R is 308.
  \end{itemize}

  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]{./Exercise/kindfns.f90}
  \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./kindfns 
Kind of i =  4  with range =   9
Kind of j =  8  with range =  18
Kind of k =  8  with range =  18
Kind of real a =  4  with precision =  6  and range =  37
Kind of real b =  8  with precision = 15  and range = 307
Kind of real c =  8  with precision = 15  and range = 307
  \end{Verbatim}
\end{frame}

\begin{frame}{Operators and Expressions}
  Fortran defines a number of operations on each data type.
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{eblock}{\scriptsize Arithmetic Operators}
      \begin{itemize}
        \footnotesize
        \item[+]: addition
        \item[-]: subtraction
        \item[*]: multiplication
        \item[/]: division
        \item[**]: exponentiation
      \end{itemize}
    \end{eblock}
    \column{0.5\textwidth}
    \begin{eblock}{\scriptsize Relational Operators (FORTRAN versions)}
      \begin{itemize}
        \footnotesize
        \item[==]: equal to (.eq.)
        \item[/=]: not equal to (.ne.)
        \item[<]: less than (.lt.)
        \item[<=]: less than or equal to (.le.)
        \item[>]: greater than (.gt.)
        \item[>=]: greater than or equal to (.ge.)
      \end{itemize}
    \end{eblock}
  \end{columns}
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{eblock}{\scriptsize Logical Expressions}
      \begin{itemize}
        \footnotesize
        \item[]{\color{tigerspurple}.AND.} intersection
        \item[]{\color{tigerspurple}.OR.} union
        \item[]{\color{tigerspurple}.NOT.} negation
        \item[]{\color{tigerspurple}.EQV.} logical equivalence
        \item[]{\color{tigerspurple}.NEQV.} exclusive or
      \end{itemize}
    \end{eblock}
    \column{0.5\textwidth}
    \begin{eblock}{\scriptsize Character Operators}
      \begin{itemize}
        \footnotesize
        \item[//]: concatenation
      \end{itemize}
    \end{eblock}
  \end{columns}
\end{frame}

\begin{frame}[allowframebreaks]{Operator Evaluations}
  \begin{itemize}
    \item In Fortran, all operator evaluations on variables is carried out from left-to-right.
    \item Arithmetic operators have a highest precedence while logical operators have the lowest precedence
    \item The order of operator precedence can be changed using parenthesis, '(' and ')'
    \item In Fortran, a user can define his/her own operators.
    \item User defined monadic operator has a higher precedence than arithmetic operators, while
    \item dyadic operators has a lowest precedence than logical operators.
  \end{itemize}
  \begin{block}{{\scriptsize Operator Precedence}}
    \begin{center}
      {
      \begin{tabular}{ccc}
        Operator & Precedence & Example \\
        \hline
        expression in () & Highest & (a+b) \\
        user-defined monadic & - & .inverse.a \\
        ** & - & 10**4 \\
        * or / & - & 10*20 \\
        monadic + or - & - & -5 \\
        dyadic + or - & - & 1+5 \\
        // & - & str1//str2 \\
        relational operators & - & a > b \\
        .not. & - & .not.allocated(a) \\
        .and. & - & a.and.b \\
        .or. & - & a.or.b \\
        .eqv. or .neqv. & - & a.eqv.b \\
        user defined dyadic & Lowest & x.dot.y\\
        \hline
      \end{tabular}
      }
    \end{center}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Expressions}
  \begin{itemize}
    \item An expression is a combination of one or more operands, zero or more operators, and zero or more pairs of parentheses.
    \item There are three kinds of expressions:
      \begin{itemize}
        \item An arithmetic expression evaluates to a single arithmetic value.
        \item A character expression evaluates to a single value of type character.
        \item A logical or relational expression evaluates to a single logical value.
      \end{itemize}
    \item Examples:
  \end{itemize}
  \begin{lstlisting}
    x + 1.0 
    97.4d0 
    sin(y) 
    x*aimag(cos(z+w)) 
    a .and. b 
    'AB' // 'wxy'
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile, allowframebreaks]{Statements}
  \begin{itemize}
    \item A statement is a complete instruction.
    \item Statements may be classified into two types: executable and non-executable.
    \item Non-executable statements are those that the compiler uses to determine various fixed parameters such as module use statements, variable declarations, function interfaces, and data loaded at compile time.
    \item Executable statements are those which are executed at runtime.
    \item A statements is normally terminated by the end-of-line marker.
    \item If a statement is too long, it may be continued by the ending the line with an ampersand (\&).
    \item Max number of characters (including spaces) in a line is 132 though it's standard practice to have a line with up to 80 characters. This makes it easier for file editors to display code or print code on paper for reading.
    \item Multiple statements can be written on the same line provided the statements are separated by a semicolon.
    \item Examples:
      \begin{lstlisting}[language={[90]Fortran}]
force = 0d0 ; pener = 0d0
do k = 1, 3
   r(k) = coord(i,k) - coord(j,k)
      \end{lstlisting}
    \item Assignment statements assign an expression to a quantity using the equals sign (=)
    \item The left hand side of the assignment statement must contain a single variable.
    \item $x + 1.0 = y$ is not a valid assignment statement.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Intrinsic Functions}
  \begin{itemize}
    \item Fortran provide a large set of intrinsic functions to implement a wide range of mathematical operations.
    \item In FORTRAN code, you may come across intrinsic functions which are prefixed with \texttt{i} for integer variables, \texttt{d} for double precision, \texttt{c} for complex single precision and \texttt{cd} for complex double precision variables.
    \item In Modern Fortran, these functions are overloaded, i.e. they can carry out different operations depending on the data type.
    \item For example: the \lstfortran{abs} function equates to $\sqrt{a^2}$ for integer and real numbers and $\sqrt{\Re^2 + \Im^2}$ for complex numbers.
  \end{itemize}
\end{frame}

\begin{frame}{Arithmetic Functions}
  \footnotesize
  \begin{minipage}{\textwidth}
    \begin{center}
      \begin{tabular}{ccc}
        Function & Action & Example \\
        \hline
        INT & conversion to integer & J=INT(X) \\
        \multirow{2}{*}{REAL} & conversion to real & X=REAL(J) \\
        & return real part of complex number & X=REAL(Z) \\
        DBLE\footnote{\tiny use real(x,kind=8) instead} & convert to double precision & X=DBLE(J) \\
        CMPLX & conversion to complex & A=CMPLX(X[,Y]) \\
        AIMAG & return imaginary part of complex number & Y=AIMAG(Z) \\
        ABS & absolute value & Y=ABS(X) \\
        MOD & remainder when I divided by J & K=MOD(I,J) \\
        CEILING & smallest integer $\ge$ to argument & I=CEILING(a) \\
        FLOOR & largest integer $\le$ to argument & I=FLOOR(a) \\
        MAX & maximum of list of arguments & A=MAX(C,D) \\
        MIN & minimum of list of arguments & A=MIN(C,D) \\
        SQRT & square root & Y=SQRT(X) \\
        EXP & exponentiation & Y=EXP(X) \\
        LOG & natural logarithm & Y=LOG(X) \\
        LOG10 & logarithm to base 10 & Y=LOG10(X) \\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
\end{frame}
  
\begin{frame}{Trignometric Functions}
  \footnotesize
  \begin{center}
    \begin{tabular}{ccc}
      Function & Action & Example \\
      \hline
      SIN & sine & X=SIN(Y) \\
      COS & cosine & X=COS(Y) \\
      TAN & tangent & X=TAN(Y) \\
      ASIN & arcsine & X=ASIN(Y) \\
      ACOS & arccosine & X=ACOS(Y) \\
      ATAN & arctangent & X=ATAN(Y) \\
      ATAN2 & arctangent(a/b) & X=ATAN2(A,B) \\
      SINH & hyperbolic sine & X=SINH(Y) \\
      COSH & hyperbolic cosine & X=COSH(Y) \\
      TANH & hyperbolic tangent & X=TANH(Y) \\
      \hline
    \end{tabular}  
  
        {\tiny hyperbolic functions are not defined for complex argument}
  \end{center}
\end{frame}

\begin{frame}{Character Functions}
  \footnotesize
  \begin{center}
    \begin{tabular}{ll}
      \hline
      len(c) & length \\
      len\_trim(c) & length of c if it were trimmed \\
      lge(s1,s2) & returns .true. if s1 follows or is equal to s2 in lexical order \\
      lgt(s1,s2) & returns .true. if s1 follows s1 in lexical order \\
      lle(s1,s2) & returns .true. if s2 follows or is equal to s1 in lexical order \\
      llt(s1,s2) & returns .true. if s2 follows s1 in lexical order \\
      \multirow{2}{*}{adjustl(s)} & returns string with leading blanks removed and \\
      &   \quad same number of trailing blanks added \\
      \multirow{2}{*}{adjustr(s)} & returns string with trailing blanks removed and \\
      & \quad same number of leading blanks added \\
      repeat(s,n) & concatenates string s to itself n times \\
      scan(s,c) & returns the integer starting position of string c within string s \\
      trim(c) & trim trailing blanks from c \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Array Intrinsic Functions}
  \footnotesize
  \begin{description}
    \item[{size(x[,n])}] The size of x (along the $n^{th}$ dimension, optional)
    \item[{sum(x[,n])}] The sum of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $sum(x) = \sum_{i,j,k,\cdots}x_{i,j,k,\cdots}$
    \item[{product(x[,n])}] The product of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $prod(x) = \prod_{i,j,k,\cdots}x_{i,j,k,\cdots}$
    \item[transpose(x)] Transpose of array x: $ x_{i,j}\Rightarrow x_{j,i}$
    \item[dot\_product(x,y)] Dot Product of arrays x and y: $ \sum_{i} x_i* y_i $
    \item[matmul(x,y)] Matrix Multiplication of arrays x and y which can be 1 or 2 dimensional arrays: $ z_{i,j} = \sum_k x_{i,k} * y_{k,j}$
    \item[conjg(x)] Returns the conjugate of x: $ a + \imath b \Rightarrow a - \imath b$
  \end{description}
\end{frame}

\section{Program Structure}
\begin{frame}[fragile,allowframebreaks]
  \frametitle{Program Structure}
%  \begin{columns}
%    \column{0.5\textwidth}
%    \begin{itemize}
%      \item A program starts with the keyword \lstfortran{PROGRAM},
%      \item followed by a program name,
%      \item followed by the \lstfortran{IMPLICIT NONE} statement,
%      \item followed by some specification statements,
%    \end{itemize}
%    \column{0.4\textwidth}
    \begin{eblock}{}
      \begin{lstlisting}[language={[90]Fortran}]
PROGRAM program-name
   IMPLICIT NONE
   [specification part]
   [execution part]
   [subprogram part]
END PROGRAM program-name
      \end{lstlisting}
    \end{eblock}
%  \end{columns}
  \begin{itemize}
%    \item followed by the execution part, and a set of internal subprograms,
%    \item followed by the keywords \lstfortran{END PROGRAM} and the program name.
    \item All Fortran statements are case insensitive.
    \item Most programmers use lower case letters with upper case letters reserved for program keywords.
    \item Are you a FORTRAN 77 or older programmer?
    \begin{itemize}
      \item Use the \lstfortran{IMPLICIT NONE} statement, avoid \lstfortran{implicit real*8(a-h,o-z)} statement. Get in the habit of declaring all variables.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Simple Temperature Conversion Problem}
  \begin{itemize}
    \item Write a simple program that 
    \begin{enumerate}
      \item Converts temperature from celsius to fahrenheit
      \item Converts temperature from fahrenheit to celsius
    \end{enumerate}
      \begin{columns}[t]
        \column{0.4\textwidth}
        \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/simple.f90}
        \column{0.6\textwidth}
        \begin{lstlisting}[basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
altair:Exercise apacheco$ gfortran simple.f90
altair:Exercise apacheco$ ./a.out 
 10C =    42.0000000     F
 40F =    0.00000000     C
        \end{lstlisting}
      \end{columns}
    \item So what went wrong? $10C = 50F$ and $40F = 4.4C$
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Type Conversion}
  \begin{itemize}
    \item In computer programming, operations on variables and constants return a result of the same type.
    \item In the temperature code, $9/5=1$ and $5/9=0$. Division between integers is an integer with the fractional part truncated.
    \item In the case of operations between mixed variable types, the variable with lower rank is promoted to the highest rank type.
  \end{itemize}
  \begin{eblock}{}
    \begin{center}
      \footnotesize
      \begin{tabular}{ccc}
        \hline
        Variable 1 & Variable 2 & Result \\
        \hline
        Integer & Real & Real \\
        Integer & Complex & Complex \\
        Real & Double Precision & Double Precision \\
        Real & Complex & Complex\\
        \hline
      \end{tabular}
    \end{center}
  \end{eblock}
  \framebreak
  \begin{itemize}
    \item As a programmer, you need to make sure that the expressions take type conversion into account
      \begin{columns}[t]
        \column{0.4\textwidth}
        \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]{./Exercise/temp.f90}
        \column{0.6\textwidth}
        \begin{lstlisting}[basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
altair:Exercise apacheco$ gfortran temp.f90
altair:Exercise apacheco$ ./a.out
 10C =    50.0000000     F
 40F =    4.44444466     C
        \end{lstlisting}
      \end{columns}
    \item The above example is not a good programming practice. 
    \item 10, 40 and 32 should be written as real numbers (10., 40. and 32.) to stay consistent. 
  \end{itemize}
\end{frame}

\section{Input and Output}
\begin{frame}[fragile,allowframebreaks]
  \frametitle{Input and Output Descriptors}
  \begin{itemize}
    \item Input and output are accomplished by operations on files.
    \item Files are identified by some form of file handle, in Fortran called the \textbf{unit number}.
    \item We have already encountered read and write command such as \lstfortran{print *,} and \lstfortran{read *,}
    \item Alternative commands for read and write are 
    \item[] \lstfortran{read(unit,*)}
    \item[] \lstfortran{write(unit,*)}
    \item There is no comma after the ')'. FORTRAN allowed statements of the form \lstfortran{write(unit,*),} which is not supported on some compilers such as IBM XLF. Please avoid this notation in FORTRAN programs.
    \item The default unit number 5 is associated with the standard input, and
    \item unit number 6 is assigned to standard output.
    \item You can replace \lstfortran{unit} with $\star$ in which case standard input (5) and output (6) file descriptors are used.
    \item The second $\star$ in \lstfortran{read/write} or the one in the \lstfortran{print */read *} corresponds to unformatted input/output.
    \item If I/O is formatted, then $\star$ is replaced with
    \item[]\lstfortran{fmt=<format specifier>}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{File Operations}
  \begin{itemize}
    \item A file may be opened with the statement
    \item[]\lstfortran{OPEN([UNIT=]un, FILE=fname [, options])}
    \item Commonly used options for the open statement are:
    \item[]\lstfortran{IOSTAT=ios}: This option returns an integer ios; its value is zero if the statement executed without error, and nonzero if an error occured.
    \item[]\lstfortran{ERR=label}: label is the label of a statement in the same program unit. In the event of an error, execution is transferred to this labelled statement. 
    \item[]\lstfortran{STATUS=istat}: This option indicates the type of file to be opened. Possible values are:
      \begin{itemize}
        \item[old]: the file specified by the file parameter must exist. 
        \item[new]: the file will be created and must not exist. 
        \item[replace]: the file will be created if it does not exist or if it exists, the file will be deleted and created i.e. contents overwritten.
        \item[unknown]: the file will be created if it doesn't exist or opened if it exists without further processing.
        \item[scratch]: file will exist until the termination of the executing program or until a \lstfortran{close} is executed on that unit.
      \end{itemize}
    \item[] \lstfortran{position=todo}: This options specifies the position where the read/write marker should be placed when opened. Possible values are:
      \begin{itemize}
        \item[rewind]: positions the file at its initial point. Convenient for rereading data from file such as input parameters.
        \item[append]: positions the file just before the endfile record. Convenient while writing to a file that already exists. If the file is \texttt{new}, then the position is at its initial point.
      \end{itemize}
      \framebreak
    \item The status of a file may be tested at any point in a program by means of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{INQUIRE([UNIT=]un, options)}
    \item[OR]
    \item[] \lstfortran{INQUIRE(FILE=fname, options)}
    \item At least one option must be specified. Options include
    \item[] \lstfortran{IOSTAT=ios}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{EXIST=lex}: Returns whether the file exists in the logical variable \lstfortran{lex}
    \item[] \lstfortran{OPENED=Iop}: Returns whether the file is open in the logical variable \lstfortran{Iop}
    \item[] \lstfortran{NUMBER=num}: Returns the unit number associated with the file, or -1 if no number is assigned to it. Generally used with the second form of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{NAMED=isnamed}: Returns whether the file has a name. Generally used with the first form of the \lstfortran{INQUIRE} statement.
    \item[] \lstfortran{NAME=fname}: Returns the name of the file in the character variable \lstfortran{fname}. Used in conjunction with the \lstfortran{NAMED} option.
    \item[] \lstfortran{READ=rd}: Returns a string \lstfortran{YES, NO}, or \lstfortran{UNKNOWN} to the character variable \lstfortran{rd} depending on whether the file is readable. If status cannot be determined, it returns \lstfortran{UNKNOWN}.
    \item[] \lstfortran{WRITE=wrt}: Similar to the \lstfortran{READ} option to test if a file is writable.
    \item[] \lstfortran{READWRITE=rdwrt}: Similar to the \lstfortran{READ} option to test if a file is both readable and writeable.
      \framebreak
    \item A file may be closed with the statement
    \item[]\lstfortran{CLOSE([UNIT=]un [, options])}
    \item Commonly used options for the close statement are:
    \item[] \lstfortran{IOSTAT=ios}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{ERR=label}: Same use as \lstfortran{open} statement.
    \item[] \lstfortran{STATUS=todo}: What actions needs to be performed on the file while closing it. Possible values are
      \begin{itemize}
        \item[keep]: file will continue to exist after the close statement, default option except for scratch files.
        \item[delete]: file will cease to exist after the close statement, default option for scratch files.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Reading and Writing Data}
  \begin{itemize}
    \item The \lstfortran{WRITE} statement is used to write to a file.
    \item Syntax for writing a list of variable, \lstfortran{varlist}, to a file associated with unit number \lstfortran{un} 
    \item[] \lstfortran{WRITE(un, options) varlist}
    \item The most common options for \lstfortran{WRITE} are:
    \item[] \lstfortran{FMT=label} A format statement label specifier.
    \item[] You can also specify the exact format to write the data to be discussed in a few slides.
    \item[] \lstfortran{IOSTAT=ios} Returns an integer indicating success or failure; zero if statement executed with no erros and nonzero if an error occured.
    \item[] \lstfortran{ERR=label} The label is a statement label to which the program should jump if an error occurs.
    \item The \lstfortran{READ} statement is used to read from a file.
    \item Syntax for reading a list of variable, \lstfortran{varlist}, to a file associated with unit number \lstfortran{un}
    \item[] \lstinline[language={[90]Fortran}]|READ(un, options) varlist|
    \item Options to the \lstfortran{READ} statement are the same as that of the \lstfortran{WRITE} statement with one additional option,
    \item[] \lstfortran{END=label} The label is a statement label to which the program should jump if the end of file is detected.
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{List-Directed I/O}
  \begin{itemize}
    \item The simplest method of getting data into and out of a program is list-directed I/O.
    \item The data is read or written as a stream into or from specified variables either from standard input or output or from a file.
    \item The unit number associate with standard input is 5 while standard output is 6.
    \item If data is read/written from/to standard input/output, then
      \begin{itemize}
        \item the unit number, \lstfortran{un} can also be replaced with $\ast$,
        \item use alternate form for reading and writing i.e. the \lstfortran{read *,} and \lstfortran{print *,} covered in an earlier slide.
        \item If data is unformatted i.e. plain ASCII characters, the option to \lstfortran{write} and \lstfortran{read} command is $\ast$
      \end{itemize}
    \item Example of list-directed output to standard output or to a file associated with unit number 8
      \begin{lstlisting}[language={[90]Fortran}]
  print *, a, b, c, arr
  write(*,*) a, b, arr
  write(6,*) a, b, c, arr
  write(8,*) a, b, c, &
    arr
      \end{lstlisting}
    \item Unlike C/C++, Fortran always writes an end-of-line marker at the end of the list of item for any \lstfortran{print} or \lstfortran{write} statements.
    \item Printing a long line with many variables may thus require continuations.
    \item Example of list-directed input from standard output or to a file associated with unit number 8
      \begin{lstlisting}[language={[90]Fortran}]
  read *, a, b, c, arr
  read(*,*) a, b, c, arr
  read(5,*) a, b, c, arr
  read(8,*) a, b, c, arr
      \end{lstlisting}
    \item When reading from standard input, the program will wait for a response from the console.
    \item Unless explicitly told to do so, no prompts to enter data will be printed. Very often programmers use a print statement to let you know that a response is expected.
      \begin{lstlisting}[language={[90]Fortran}]
 print *, 'Please enter a value for the variable inp'
 read *, inp
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Formatted Input/Output}
  \begin{itemize}
    \item List-directed I/O does not always print the results in a particularly readable form.
    \item For example, a long list of variable printed to a file or console may be broken up into multiple lines.
    \item In such cases it is desirable to have more control over the format of the data to be read or written.
    \item Formatted I/O requires that the programmer control the layout of the data.
    \item The type of data and the number of characters that each element may occupy must be specified.
      \framebreak
    \item A formatted data description must adhere to the generic form,
    \item[] \lstfortran{nCw.d}
    \item[] where
      \begin{itemize}
        \item \lstfortran{n} is an integer constant that specifies the number of repititions (default 1 can be omitted),
        \item \lstfortran{C} is a letter indicating the type of the data variable to be written or read,
        \item \lstfortran{w} is the total number of spaces allocated to this variable, and,
        \item \lstfortran{d} is the number of spaces allocated to the fractional part of the variable. Integers are padded with zeros for a total width of \lstfortran{w} provided $d\le w$.
        \item The decimal (.) and \lstfortran{d} designator are not used for integers, characters or logical data types. Note that \lstfortran{d} designator has a different meaning for integers and is usually referred to as \lstfortran{m} to avoid confusion.
      \end{itemize}
    \item Collectively, these designators are called \textbf{edit descriptors}.
    \item The space occupied by an item of data or variable is called \textit{field}.
  \end{itemize}
  \begin{minipage}{\textwidth}
    \begin{center}
      \scriptsize
      \begin{tabular}{|c|c|c|l|}
        \hline
        Data Type & Edit Descriptor & Examples & Result\\
        \hline
        Integer & nIw[.m] & I5.5 & \lstinline[showspaces=true]|00010|\\
        Real\footnote{\tiny For complex variables, use two appropriate real edit descriptors } (floating point) & nFw.d & F12.6 & \lstinline[showspaces=true]|   10.123456|\\
        Real (exponential) & Ew.d[en]\footnote{\tiny en is used when you need more than 2 digits in the exponent as in 100. E15.7e4 to represent $2.3\times10^{1021}$} & E15.8 & \lstinline[showspaces=true]|   0.12345678E1| \\
        Real (engineering) &  ESw.d\footnote{\tiny data is printed in multiples of 1000} & ES12.3 & \lstinline[showspaces=true]|   50.123E-3| \\
        Character & nAw & A12 & \lstinline[showspaces=true]|     Fortran| \\
        \hline
      \end{tabular}
    \end{center}
  \end{minipage}
  \begin{itemize}
    \item \textbf{Control descriptors} alter the input or output by addings blanks, new lines and tabs.
  \end{itemize}
  \begin{center}
    \scriptsize
    \begin{tabular}{|c|c|l|}
      \hline
      Space & \texttt{n}X & add \texttt{n} spaces \\
      \multirow{3}{*}{Tabs} & t\texttt{n} & tab to position \texttt{n} \\
      & tl\texttt{n} & tab left \texttt{n} positions \\
      & tr\texttt{n} & tab right \texttt{n} positions \\
      New Line & / & Create a new line record \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Format Statements}
  \begin{itemize}
    \item Edit descriptors must be used in conjunction with a \lstfortran{PRINT}, \lstfortran{WRITE} or \lstfortran{READ} statement.
    \item In the simplest form, the format is enclosed in single quotes and parentheses as as argument to the keyword.
      \begin{lstlisting}[language={[90]Fortran}]
 print '(I5,5F12.6)', i, a, b, c, z ! complex z
 write(6,'(2E15.8)') arr1, arr2
 read(5,'(2a)') firstname, lastname
      \end{lstlisting}
      \item If the same format is to be used repeatedly or it is complicated, the \lstfortran{FORMAT} statement can be used.
      \item The \lstfortran{FORMAT} statement must be labeled and the label is used in the input/output statement to reference it
        \begin{lstlisting}[language={[90]Fortran}]
 label FORMAT(formlist)
 PRINT label, varlist
 WRITE(un, label) varlist
 READ(un, label) varlist
        \end{lstlisting}
      \item The \lstfortran{FORMAT} statements can occur anywhere in the same program unit. Most programmers list all \lstfortran{FORMAT} statements immediately after the type declarations before any executable statements.
        \begin{lstlisting}[language={[90]Fortran}]
 10 FORMAT(I5,5F12.6)
 20 FORMAT(2E15.8)
 100 FORMAT(2a)
 
 print 10, i, a, b, c, z ! complex z
 write(6,20) arr1, arr2
 read(5,100) firstname, lastname
        \end{lstlisting}
  \end{itemize}
%  \lstinline[language={[90]Fortran}]|print '(20X,I5,20X,I5/21X,I4,21X,I4)', N, M, I, J|
%  \lstinline[showspaces=true]|                    12345                    12345|
%  \lstinline[showspaces=true]|                     1234                     1234| 
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Namelist}
  \begin{itemize}
    \item Many scientific codes have a large number of input parameters.
    \item Remembering which parameter is which and also the order in which they are to read, make creating input files very tedious.
    \item Fortran provides \lstfortran{NAMELIST} input simplify this situation.
    \item In a \lstfortran{NAMELIST}, parameters are specified by name and value and can appear in any order.
    \item The \lstfortran{NAMELIST} is declared as a non-executable statement in the subprogram that reads the input and the variables that can be specified in it are listed.\\
      \lstfortran{NAMELIST /name/ varlist}
    \item Namelists are read with a special form of the \lstfortran{READ} statement.\\
      \lstfortran{READ(un,[nml=]name)}
      \framebreak
    \item The input file must follow a particular format:
      \begin{itemize}
        \item begin with an ampersand followed by the name of the namelist (\&name) and ends with a slash (/),
        \item variables are specified with an equals sign (=) between the variable name and its value,
        \item only statis objects may be part of a namelist; i.e. dynamically allocated arrays, pointers and the like are not permitted
      \end{itemize}
    \item For example, consider a program that declares a namelist as follows:\\
      \lstfortran{namelist/moldyn/natom,npartdim,tempK,nstep,dt}
    \item The corresponding input file can take the form
      \lstinputlisting{./MolDyn/slides/md.inp}
    \item Note:
      \begin{itemize}
        \item parameters may appear in any order in the input file, and
        \item may be omitted if they are not needed i.e. they can take default values that is specified in the program
      \end{itemize}
    \item The above namelist can be read with a single statement as in (other options to \lstfortran{READ} statement can be added if needed)\\
      \lstfortran{READ(10, nml=moldyn)}
    \item To write the values of a namelist is similar\\
      \lstfortran{WRITE(20, nml=moldyn)}
    \item Namelist names and variables are case insensitive.
    \item The namelist designator cannot have blanks
    \item Arrays may be namelist variables, but all the values of the array must be listed after the equals sign following its name
    \item If any variable name is repeated, the final value is taken.
    \item Namelist are convenient when you want to read different input for different types of calculations within the same program.
    \item Amber Molecular Dynamics package uses namelist to read input. The following is the input file from Amber's test directory.
      \begin{lstlisting}
 &cntrl 
   ntx=1, imin=5, ipb=1, inp=2, ntb=0,  
 /      
 &pb
   npbverb=0, istrng=0, epsout=80.0, epsin=1.0, space=0.5,  
   accept=0.001, sprob=1.6, radiopt=1, dprob=1.6,   
 /      
      \end{lstlisting}
    \item If multiple variables are listed on the same line, they need to be separated by a comma (,) not semicolon(;)
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Internal Read and Write}
  \begin{itemize}
    \item Fortran allows a programmer to cast numeric types to character type and vice versa.
    \item The character variable functions as an internal file.
    \item An \textbf{internal write} converts from numeric to character type, while
    \item an \textbf{internal read} converts from character to numeric type.
    \item This is useful feature particularly for writing output of arrays that are dynamically allocated.
    \item Example: Convert an integer to a character
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=10) :: num
 INTEGER           :: inum
 WRITE(NUM,'(A10)') inum
      \end{lstlisting}
      \framebreak
    \item Example: Convert an character to an integer
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=10) :: num = "435"
 INTEGER   :: inum
 READ(inum,'(I4)') num
      \end{lstlisting}
    \item Example: Writing data when parameters are not known at compile time
      \begin{lstlisting}[language={[90]Fortran}]
 CHARACTER(len=23) :: xx
 CHARACTER(len=13) :: outfile
 INTEGER  :: natoms, istep
 REAL     :: time
 REAL, ALLOCATABLE, DIMENSION(:) :: coords

 natoms = 100 ; ALLOCATE(coords(natoms*3))

 WRITE(xx,'(A,I5,A)') '(F12.6,', 3*natoms, '(2X,E15.8))'
 WRITE(outfile,'(A8,I5.5,A4)') 'myoutput', istep, '.dat'

 OPEN(unit = 10, file = outfile)
 WRITE(10, xx) time, coords(:)
      \end{lstlisting}
  \end{itemize}
\end{frame}


\section{Control Constructs}
\begin{frame}[fragile] {Control Constructs}
  \begin{itemize}
    \item A Fortran program is executed sequentially
      \begin{lstlisting}[language={[90]Fortran},mathescape]
program somename 
  variable declarations
  statement 1
  statement 2
  $\cdots$
end program somename
      \end{lstlisting}
    \item Control Constructs change the sequential execution order of the program
      \begin{enumerate} %\itemsep1pt \parskip0pt \parsep0pt
        \item Conditionals: \lstfortran{IF}
        \item Loops: \lstfortran{DO}
        \item Switches: \lstfortran{SELECT/CASE}
        \item Branches: \lstfortran{GOTO} (obsolete in Fortran 95/2003, use CASE instead)
      \end{enumerate}
  \end{itemize}
\end{frame}

\subsection{Conditionals}
\begin{frame}[fragile]{If Statement}
  \begin{itemize}
    \item The general form of the \lstfortran{if} statement
    \item[] \lstfortran{if ( expression ) statement}
    \item When the \lstfortran{if} statement is executed, the logical expression is evaluated. 
    \item If the result is true, the statement following the logical expression is executed; otherwise, it is not executed.
    \item The statement following the logical expression \textbf{cannot} be another \lstfortran{if} statement. Use the \lstfortran{if-then-else} construct instead.
    \item[] \lstfortran{if (value < 0) value = 0 }
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{If-then-else Construct}
  \begin{itemize}
    \item The \lstfortran{if-then-else} construct permits the selection of one of a number of blocks during execution of a program
    \item The \lstfortran{if-then} statement is executed by evaluating the logical expression.
    \item If it is true, the block of statements following it are executed. Execution of this block completes the execution of the entire \lstfortran{if} construct.
    \item If the logical expression is false, the next matching \lstfortran{else if}, \lstfortran{else} or \lstfortran{end if} statement following the block is executed.
      \begin{lstlisting}[language={[90]Fortran},mathescape,basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( expression 1) then
  executable statements
else if ( expression 2 ) then
  executable statements
else if $\cdots$
  $\vdots$
else
  executable statements
end if
      \end{lstlisting}
    \item Examples:
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( x < 50 ) then
  GRADE = 'F'
else if ( x >= 50 .and. x < 60 ) then
  GRADE = 'D'
else if ( x >= 60 .and. x < 70 ) then
  GRADE = 'C'
else if ( x >= 70 .and. x < 80 ) then
  GRADE = 'B'
else 
  GRADE = 'A'
end if
      \end{lstlisting}
    \item The \lstfortran{else if} and \lstfortran{else} statements and blocks may be omitted.
    \item If \lstfortran{else} is missing and none of the logical expressions are true, the \lstfortran{if-then-else} construct has no effect.
    \item The \lstfortran{end if} statement must not be omitted.
    \item The \lstfortran{if-then-else} construct can be nested and named.
  \end{itemize}
  \framebreak
  \begin{columns}
    \column{6cm}
    \begin{block}{\scriptsize no \bftt{else if}}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
[outer_name:] if ( expression ) then
  executable statements
else
  executable statements
  [inner_name:] if ( expression ) then
    executable statements
  end if [inner_name]
end if [outer_name]
      \end{lstlisting}
    \end{block}
    \column{5cm}
    \begin{block}{\scriptsize no \bftt{else}}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{5}\selectfont\ttfamily]
if ( expression ) then
  executable statements
else if ( expression ) then
  executable statements
else if ( expression ) then
  executable statements
end if
      \end{lstlisting}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Finding roots of quadratic equation}
  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]{./Exercise/quad_roots.f90}
  \framebreak
  \begin{columns}[t]
    \column{0.5\textwidth}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./root.x 
 ============================================
  Program to solve a quadratic equation
     ax^2 + bx + c = 0 
  If d = b^2 - 4ac >= 0 
    then solutions are: 
      (-b +/- sqrt(d) )/2a 
 ============================================
 Enter coefficients a,b and c
1 2 1

  Quadratic equation to solve is: 
   1.000x^2 + 2.000x + 1.000 = 0

Both solutions are equal:    -1.000000
    \end{Verbatim}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./root.x 
 ============================================
  Program to solve a quadratic equation
     ax^2 + bx + c = 0 
  If d = b^2 - 4ac >= 0 
    then solutions are: 
      (-b +/- sqrt(d) )/2a 
 ============================================
 Enter coefficients a,b and c
0 1 2

  Quadratic equation to solve is: 
   0.000x^2 + 1.000x + 2.000 = 0

 Input equation is a Linear equation with 
 Solution: -2.000
    \end{Verbatim}
    \column{0.5\textwidth}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./root.x 
 ============================================
  Program to solve a quadratic equation
     ax^2 + bx + c = 0 
  If d = b^2 - 4ac >= 0 
    then solutions are: 
      (-b +/- sqrt(d) )/2a 
 ============================================
 Enter coefficients a,b and c
2 1 1

  Quadratic equation to solve is: 
    2.000x^2 +  1.000x +  1.000 = 0

 Solution is not real
 (-0.250+0.661i) and (-0.250-0.661i)
    \end{Verbatim}
  \end{columns}
\end{frame}

\subsection{Switches}
\begin{frame}[fragile,allowframebreaks]{Case Construct}
  \begin{itemize}
    \item The \lstfortran{case} construct permits selection of one of a number of different block of instructions.
    \item The value of the expression in the \lstfortran{select case} should be an integer or a character string.
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[case_name:] select case ( expression )
  case ( selector )
    executable statement
  case ( selector )
    executable statement
  case default
    executable statement
end select [case_name]
      \end{lstlisting}
    \item The \lstfortran{selector} in each \lstfortran{case} statement is a list of items, where each item is either a single constant or a range of the same type as the expression in the \lstfortran{select case} statement.
    \item A range is two constants separated by a colon and stands for all the values between and including the two values. 
    \item The \lstfortran{case default} statement and its block are optional.
    \item The \lstfortran{select case} statement is executed as follows:
    \begin{enumerate}
      \item Compare the value of expression with the case selector in each case. If a match is found, execute the following block of statements.
      \item If no match is found and a \lstfortran{case default} exists, then execute those block of statements.
    \end{enumerate}
  \end{itemize}
  \begin{ablock}{Notes}
    \begin{itemize}
      \item The values in selector must be unique.
      \item Use \lstfortran{case default} when possible, since it ensures that there is something to do in case of error or if no match is found.
      \item \lstfortran{case default} can be anywhere in the \lstfortran{select case} construct. The preferred location is the last location in the \lstfortran{case} list.
    \end{itemize}
  \end{ablock}
  \framebreak
  \begin{itemize}
    \item Example for character case selector
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
select case ( traffic_light )
  case ( "red" )
    print *, "Stop"
  case ( "yellow" )
    print *, "Caution"
  case ( "green" )
    print *, "Go"
  case default
    print *, "Illegal value: ", traffic_light
end select 
      \end{lstlisting}
    \item Example for integer case selector
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
select case ( score )
  case ( 50 : 59 )
    GRADE = "D"
  case ( 60 : 69 )
    GRADE = "C"
  case ( 70 : 79 )
    GRADE = "B"
  case ( 80 : ) 
    GRADE = "A"
  case default
    GRADE = "F"
end select
      \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Loops}
\begin{frame}[fragile,allowframebreaks]{Do Construct}
  \begin{itemize}
    \item The looping construct in fortran is the \lstfortran{do} construct.
    \item The block of statements called the loop body or \lstfortran{do} construct body is executed repeatedly as indicated by loop control.
    \item A \lstfortran{do} construct may have a construct name on its first statement
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do loop_control
  execution statements
end do [do_name]
      \end{lstlisting}
    \item There are two types of loop control:
    \begin{enumerate}
      \item Counting: a variable takes on a progression of integer values until some limit is reached.
      \begin{itemize}
        \item[$\vardiamond$] \textit{variable = start, end[, stride] }
        \item[$\vardiamond$] \textit{stride} may be positive or negative integer, default is 1 which can be omitted.
      \end{itemize}
      \item General: a loop control is missing
    \end{enumerate}
    \item Before a \lstfortran{do} loop starts, the expression \textit{start, end} and \textit{stride} are evaluated. These values are not re-evaluated during the execution of the \lstfortran{do} loop.
    \item \textit{stride} cannot be zero.
    \item If \textit{stride} is positive, this \lstfortran{do} counts up.
    \begin{enumerate}
      \scriptsize
      \item The \textit{variable} is set to \textit{start}
      \item If \textit{variable} is less than or equal to \textit{end}, the block of statements is executed.
      \item Then, \textit{stride} is added to \textit{variable} and the new \textit{variable} is compared to \textit{end}
      \item If the value of \textit{variable} is greater than \textit{end}, the \lstfortran{do} loop completes, else repeat steps 2 and 3
    \end{enumerate}
    \item If \textit{stride} is negative, this \lstfortran{do} counts down.
    \begin{enumerate}
      \scriptsize
      \item The \textit{variable} is set to \textit{start}
      \item If \textit{variable} is greater than or equal to \textit{end}, the block of statements is executed.
      \item Then, \textit{stride} is added to \textit{variable} and the new \textit{variable} is compared to \textit{end}
      \item If the value of \textit{variable} is less than \textit{end}, the \lstfortran{do} loop completes, else repeat steps 2 and 3
    \end{enumerate}
  \end{itemize}
  \framebreak
  \begin{columns}[t]
    \column{5.5cm}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{./Exercise/factorial1.f90}
    \column{5.5cm}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{./Exercise/factorial2.f90}
  \end{columns}
  \begin{columns}
    \column{5.5cm}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./fact1
 Enter an integer < 15 
10
  10!=        3628800
    \end{Verbatim}
    \column{5.5cm}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./fact2
 Enter an integer < 15 
10
  10!!=           3840
    \end{Verbatim}
  \end{columns}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Do Construct: Nested}
  \begin{itemize}
    \item The \lstfortran{exit} statement causes termination of execution of a loop. 
    \item If the keyword \lstfortran{exit} is followed by the name of a do construct, that named loop (and all active loops nested within it) is exited and statements following the named loop is executed.
    \item The \lstfortran{cycle } statement causes termination of the execution of \textit{one iteration} of a loop.
    \item[] The \lstfortran{do} body is terminated, the \lstfortran{do} variable (if present) is updated, and control is transferred back to the beginning of the block of statements that comprise the \lstfortran{do} body. 
    \item If the keyword \lstfortran{cycle} is followed by the name of a construct, all active loops nested within that named loop are exited and control is transferred back to the beginning of the block of statements that comprise the named \lstfortran{do} construct.
  \end{itemize}
  \framebreak
  \begin{columns}[t]
    \column{5.5cm}
    \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]{Exercise/nested.f90}
    \column{5.5cm}
    \begin{Verbatim}[fontsize=\fontsize{5}{6}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./nested 
     0     0    0.000000    0.000000    0.000000
     0    45    0.000000    0.785398    0.000000
     0   135    0.000000    2.356194   -0.000000
     0   180    0.000000    3.141593   -0.000000
    45     0    0.785398    0.000000    0.707107
    45    45    0.785398    0.785398    1.000000
    45   135    0.785398    2.356194   -1.000000
    45   180    0.785398    3.141593   -0.707107
    90     0    1.570796    0.000000    1.000000
    90    45    1.570796    0.785398    1.414214
    90   135    1.570796    2.356194   -1.414214
    90   180    1.570796    3.141593   -1.000000
   135     0    2.356194    0.000000    0.707107
   135    45    2.356194    0.785398    1.000000
   135   135    2.356194    2.356194   -1.000000
   135   180    2.356194    3.141593   -0.707107
   180     0    3.141593    0.000000    0.000000
   180    45    3.141593    0.785398    0.000000
   180   135    3.141593    2.356194   -0.000000
   180   180    3.141593    3.141593   -0.000000
    \end{Verbatim}
  \end{columns}
\end{frame}


\begin{frame}[fragile]{Do Construct: General}
  \begin{itemize}
    \item The General form of a \lstfortran{do} construct is
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do
  executable statements
end do [do_name]
      \end{lstlisting}
    \item The \lstfortran{executable statements} will be executed indefinitly.
    \item To exit the \lstfortran{do} loop, use the \lstfortran{exit} or \lstfortran{cycle} statement.
    \item The \lstfortran{exit} statement causes termination of execution of a loop.
    \item The \lstfortran{cycle } statement causes termination of the execution of \textit{one iteration} of a loop.
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
    cycle finite
  end if inner
  if ( i > 100 ) exit finite
end do finite
      \end{lstlisting}
  \end{itemize}
\end{frame}


\begin{frame}[fragile]{Do While Construct}
  \begin{itemize}
    \item If a condition is to be tested at the top of a loop, a \lstfortran{do ... while } loop can be used
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
[do_name:] do while ( expression )
  executable statements
end do [do_name]
      \end{lstlisting}
    \item The loop only executes if the logical expression evaluates to \lstfortran{.true.}
  \end{itemize}
  \begin{columns}[t]
    \column{0.4\textwidth}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do while ( i <= 100 )
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
  end if inner
end do finite
    \end{lstlisting}
    \column{0.4\textwidth}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
finite: do
  i = i + 1
  inner: if ( i < 10 ) then
    print *, i
    cycle finite
  end if inner
  if ( i > 100 ) exit finite
end do finite
    \end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}{End of Day 1}
  \begin{itemize}
    \item Thats all for Day 1
    \item Any Question?
    \item In the second part of the tutorial we will cover advanced topics:
      \begin{enumerate}
        \item Arrays: Dynamic Arrays, Array Conformation concepts, Array declarations and Operations, etc.
        \item Procedures: Modules, Subroutines, Functions, etc.
        \item Object Oriented Concepts: Derived Type Data, Generic Procedures and Operator Overloading.
      \end{enumerate}
  \end{itemize}
\end{frame}
\begin{frame}{References}
  \begin{itemize}
    \item Fortran 95/2003 Explained, Michael Metcalf
    \item Modern Fortran Explaned, Michael Metcalf
    \item Guide to Fortran 2003 Programming, Walter S. Brainerd
    \item Introduction to Programming with Fortran: with coverage of Fortran 90, 95, 2003 and 77, I. D. Chivers
    \item Fortran 90 course at University of Liverpool, \url{http://www.liv.ac.uk/HPC/F90page.html}
    \item Introduction to Modern Fortran, University of Cambridge, \url{http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Fortran}
    \item Scientific Programming in Fortran 2003: A tutorial Including Object-Oriented Programming, Katherine Holcomb, University of Virginia.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Additional Help}
  \begin{itemize}
    \item Online Courses: \url{http://moodle.hpc.lsu.edu}
    \item Contact us
    \begin{enumerate}
      {\scriptsize
        \item[$\vardiamond$]Email ticket system: sys-help@loni.org
        \item[$\vardiamond$]Telephone Help Desk: 225-578-0900
        \item[$\vardiamond$]Instant Messenger (AIM, Yahoo Messenger, Google Talk)
        \begin{enumerate}
          {\scriptsize
            \item[$\bigstar$]Add "lsuhpchelp"
          }
        \end{enumerate}
      }
    \end{enumerate}
  \end{itemize}
\end{frame}

\section{Exercise}
\begin{frame}[allowframebreaks]{Calculate pi by Numerical Integration}
  \begin{columns}
    \column{5cm}
    \begin{itemize}
      \item We know that
      \begin{align*}
        \int^1_0 \dfrac{4.0}{(1+x^2)}\, dx = \pi
      \end{align*}
      \item So numerically, we can approxiate pi as the sum of a number of rectangles
      \begin{align*}
        \sum^N_{i=0}\,F(x_i)\Delta x \approx \pi
      \end{align*}
      \item[] \fontsize{4}{5}{ Meadows et al, A ``hands-on'' introduction to OpenMP, SC09 }
    \end{itemize}
    \column{5cm}
    \begin{center}
      \includegraphics[width=4cm]{../OpenMP/pi}
    \end{center}
  \end{columns}

  \begin{algorithm}[H]
    \caption{Pseudo Code for Calculating Pi}
    \begin{algorithmic}
        \Function{calculate\_pi}{}
        \State $step \gets 1/n$
        \State $sum \gets 0$
        \Do{$i \gets 0\cdots n$}
        \State $x \gets (i+0.5)*step; sum \gets sum + 4/(1+x^2)$
        \EndDo
        \State $pi \gets sum * step$
        \EndFunction
    \end{algorithmic}
  \end{algorithm}
\end{frame}



\begin{frame}{\small SAXPY}
  \begin{itemize}
    \item SAXPY is a common operation in computations with vector processors included as part of the BLAS routines
    \item[] $y\leftarrow \alpha x + y$
%    \item SAXPY is a combination of scalar multiplication and vector addition
    \item Write a SAXPY code to multiply a vector with a scalar.
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code for SAXPY}
    \begin{algorithmic}
      \Program{saxpy}{}
      \State $n \gets$ some large number
      \State $x(1:n) \gets$ some number say, 1
      \State $y(1:n) \gets$ some other number say, 2
      \State $a \gets$ some other number ,say, 3
      \Do{$i \gets 1\cdots n$}
      \State $y_i \gets y_i + a * x_i$
      \EndDo
      \EndProgram{saxpy}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

\begin{frame}[allowframebreaks]{Matrix Multiplication}
  \begin{itemize}
    \item Most Computational code involve matrix operations such as matrix multiplication.
    \item Consider a matrix {\bf C} which is a product of two matrices {\bf A} and {\bf B}:
    \item[] Element {\it i,j} of {\bf C} is the dot product of the $i^{th}$ row of {\bf A} and $j^{th}$ column of {\bf B}
    \item Write a MATMUL code to multiple two matrices.
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{../OpenMP/matmul}
  \end{center}

  \begin{algorithm}[H]
    \caption{Pseudo Code for MATMUL}
    \begin{algorithmic}
      \Program{matmul}{}
      \State $m,n \gets$ some\,large\,number $\le 1000$
      \State Define $a_{mn}, b_{nm}, c_{mm}$
      \State $a_{ij} \gets i+j; b_{ij} \gets i-j; c_{ij} \gets 0$
      \Do{$i \gets 1\cdots m$}
      \Do{$j \gets 1\cdots m$}
      \State $c_{i,j} \gets \sum^{n}_{k=1} a_{i,k}*b_{k,j}$
      \EndDo
      \EndDo
      \EndProgram{matmul}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

%\begin{frame}[allowframebreaks]{Molecular Dynamics}
%  \begin{itemize}
%    \item Molecular dynamics (MD) is a computer simulation of physical movements of atoms and molecules in the context of N-body simulation.
%    \item The atoms and molecules are allowed to interact for a period of time, giving a view of the motion of the atoms described by Newton's Law of Motion.
%    \item A simple MD code is classic example for understanding various concepts of Modern Fortran.
%    \item Take the code md-orig.f90 and modify it using the concepts learned. This exercise is designed for the second day of the tutorials wherein you can modify the code using various concepts covered viz,
%      \begin{enumerate}
%        \item Dynamical Allocation of Arrays,
%        \item Array operations,
%        \item Modules, subroutines and functions,
%        \item Derived Types,
%        \item Object Oriented Concepts such as subroutine, function and operator overloading.
%      \end{enumerate}
%    \item You do not need to start working on this on the first day but getting familiar with the code is a good start for now.
%  \end{itemize}
%\end{frame}

\part{Advanced Concepts in Fortran Programming}
\frame[label=day2]{\partpage}
\begin{frame}{Outline of Part II}
  \tableofcontents[part=2,hideallsubsections]
\end{frame}

\section{Arrays}
\begin{frame}{Arrays}
  \begin{itemize}
    \item Arrays (or matrices) hold a collection of different values at the same time.
    \item Individual elements are accessed by subscripting the array.
    \item A 10 element array is visualized as
    \item[]
      \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|}
          \hline
          1 & 2 & 3 & $\cdots$ & 8 & 9 & 10 \\
          \hline
        \end{tabular}
      \end{center}
    \item[] while a 4x3 array as
    \item[]
      \begin{center}
        \includegraphics[width=4cm]{./array1}
      \end{center}
    \item Each array has a type and each element of holds a value of that type.
  \end{itemize}
\end{frame} 

\begin{frame}[fragile]{Array Declarations}
  \begin{itemize}
    \item The \lstfortran{dimension} attribute declares arrays.
    \item Usage: \lstfortran{dimension(lower\_bound:upper\_bound)}
    \item[] Lower bounds of one \lstfortran{(1:)} can be omitted
    \item Examples:
      \begin{lstlisting}[language={[90]Fortran}]
integer, dimension(1:106) :: atomic_number
real, dimension(3,0:5,-10:10) :: values
character(len=3),dimension(12) :: months
      \end{lstlisting}
    \item Alternative form for array declaration
      \begin{lstlisting}[language={[90]Fortran}]
integer :: days_per_week(7), months_per_year(12)
real :: grid(0:100,-100:0,-50:50)
complex :: psi(100,100)
      \end{lstlisting}
    \item Another alternative form which can be very confusing for readers
      \begin{lstlisting}[language={[90]Fortran}]
integer, dimension(7) :: days_per_week, months_per_year(12)
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}{Array Terminology}
  \begin{itemize}
    \item[] \lstfortran{real :: a(0:20), b(3,0:5,-10:10)}
  \end{itemize}
  \begin{description}
    \item[Rank:] Number of dimensions.
    \item[] {\lstfortran{a}} has rank 1 and {\lstfortran{b}} has rank 3
    \item[Bounds:] upper and lower limits of each dimension of the array.
    \item[] {\lstfortran{a}} has bounds 0:20 and {\lstfortran{b}} has bounds 1:3, 0:5 and -10:10
    \item[Extent:] Number of element in each dimension
    \item[] {\lstfortran{a}} has extent 21 and {\lstfortran{b}} has extents 3,6 and 21
    \item[Size:] Total number of elements.
    \item[] {\lstfortran{a}} has size 21 and {\lstfortran{b}} has 30
    \item[Shape:] The shape of an array is its rank and extent
    \item[] \lstfortran{a} has shape 21 and \lstfortran{b} has shape (3,6,21)
  \end{description}
  \begin{itemize}
    \item Arrays are conformable if they share a shape.
    \item The bounds do not have to be the same
    \item[] \lstfortran{c(4:6) = d(1:3)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Array Visualization}
  \begin{itemize}
    \item Define arrays \lstfortran{a,b,c} and \lstfortran{d} as follows
      \begin{lstlisting}[language={[90]Fortran}]
real,dimension(15) :: a
real,dimension(-4:0,0:2) :: b
real,dimension(5,3) :: c
real,dimension(4:8,2:4) :: d
      \end{lstlisting}
  \end{itemize}
  \begin{center}
    \includegraphics[width=5cm,clip=true]{./array2-3-1}
%    \includegraphics[width=4cm]{./array2}\\
%    \includegraphics[width=4cm]{./array3}
  \end{center}
\end{frame}

\begin{frame}{Array Conformance}
  \begin{itemize}
    \item Array or sub-arrays must conform with all other objects in an expression
      \begin{enumerate}
        \item a scalar conforms to an array of any shape with the same value for every element
        \item[] \lstfortran{c = 1.0} is the same as \lstfortran{c(:,:) = 1.0}
        \item two array references must conform in their shape.
      \end{enumerate}
  \end{itemize}
  \begin{center}
    \includegraphics[width=4cm]{./array4}
  \end{center}
\end{frame}

\begin{frame}{Array Element Ordering}
  \begin{itemize}
    \item Fortran is a column major form i.e. elements are added to the columns seqeuntially. This ordering can be changed using the \lstfortran{reshape} intrinsic.
  \end{itemize}
  \begin{center}
    \includegraphics[width=6cm,clip=true]{./array5}
  \end{center}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Array Constructors}
  \begin{itemize}
    \item Used to give arrays or sections of arrays specific values
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
implicit none
integer :: i
integer, dimension(10) :: ints
character(len=5),dimension(3) :: colors
real, dimension(4) :: height
height = (/5.10, 5.4, 6.3, 4.5 /)
colors = (/'red  ', 'green', 'blue ' /)
ints = (/ 30, (i = 1, 8), 40 /)
      \end{lstlisting}
    \item constructors and array sections must conform.
    \item[] \lstfortran{ints = (/ 30, (i = 1, 10), 40/)} is invalid
    \item strings should be padded so that character variables have correct length.
    \item use \lstfortran{reshape} intrinsic for arrays for higher ranks
    \item \lstfortran{(i = 1, 8)} is an implied \lstfortran{do}.
    \item You can also specify a stride in the implied \lstfortran{do}.
    \item[] \lstfortran{ints = (/ 30, (i = 1, 16, 2), 40 /)}
    \item {\color{red}There should be no space between / and ( or )}
      \framebreak
    \item \lstfortran{reshape(source, shape, pad, order)} constructs an array with a specified shape \lstfortran{shape} starting from the elements in a given array \lstfortran{source}.
    \item If \lstfortran{pad} is not included then the size of \lstfortran{source} has to be at least \lstfortran{product (shape)}. 
    \item If \lstfortran{pad} is included it has to have the same type as \lstfortran{source}. 
    \item If \lstfortran{order} is included, it has to be an \lstfortran{integer} array with the same shape as \lstfortran{shape} and the values must be a permutation of (1,2,3,...,N), where N (max value is 7) is the number of elements in \lstfortran{shape}.
  \end{itemize}
  \begin{columns}[t]
    \column{2cm}
    {\tiny
      \[ \left( \begin{array}{ccc}
        0 & 0 & 0 \\
        0 & a & a \\
        a & 0 & a \\
        a & a & 0
      \end{array}\right) \]
    }
    \column{4cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
  rcell = reshape( (/ &
       0.d0, 0.d0, a,    a,   &
       0.d0, a,    0.d0, a,   &
       0.d0, a,    a,    0.d0 &
       /),(/4,3/) )
    \end{lstlisting}
    \column{4cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
  rcell = reshape( (/ &
       0.d0, 0.d0, 0.d0 &
       0.d0, a   , a    &
       a,    0.d0, a    &
       a,    a,    0.d0 &
       /),(/4,3/),order=(/2,1/))
    \end{lstlisting}
  \end{columns}
  \begin{itemize}
    \item In Fortran, for a multidimensional array, the first dimension has the fastest index while the last dimension has the slowest index i.e. memory locations are continuous for the last dimension. 
    \item The \lstfortran{order} statement allows the programmer to change this order. The last example above sets the memory location order which is consistent to that in C/C++.
    \item Arrays can be initialized as follows during variable declaration
  \end{itemize}
  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
 integer, dimension(4) :: imatrix = (/ 2, 4, 6, 8/)
 character(len=*),dimension(3) :: colors = (/'red  ', 'green', 'blue '/)}
 ! All strings must be the same length}
 real, dimension(4) :: height = (/5.10, 5.4, 6.3, 4.5/)
 integer, dimension(10) :: ints = (/ 30, (i = 1, 8), 40/)
 real, dimension(4,3), parameter :: rcell = reshape( (/0.d0, 0.d0, 0.d0, 0.d0,\&
   a, a, a,0.d0, a, a, a, 0.d0 /),(/4,3/),order=(/2,1/)) 
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Array Syntax}
  \begin{itemize}
    \item Arrays can be treated as a single variable when performing operations
    \begin{enumerate}
      \item set whole array to a constant: \lstfortran{a = 0.0}
      \item can use intrinsic operators between conformable arrays (or sections)
      \item[] {\lstfortran{ b = c * d + b**2 }}
      \item[] this is equivalent to
        \begin{lstlisting}[language={[90]Fortran},mathescape]
b(-4,0) = c(1,1) * d(4,2) + b(-4,0)**2 
b(-3,0) = c(2,1) * d(5,2) + b(-3,0)**2 
$\cdots$
b(-4,0) = c(1,1) * d(4,2) + b(-4,0)**2 
b(-4,1) = c(1,2) * d(4,3) + b(-4,1)**2 
$\cdots$
b(-3,2) = c(4,3) * d(7,4) + b(-3,2)**2 
b(-4,2) = c(5,3) * d(8,4) + b(-4,2)**2 
        \end{lstlisting}
      \item elemental intrinsic functions can be used: \lstfortran{ b = sin(c) + cos(d)}
      \item All operations/functions are applied element by element
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Array Sections}
  \begin{columns}[t]
    \column{7cm}
    \begin{itemize}
      \scriptsize
      \item[] \lstfortran{real, dimension(6:6) :: a}
      \item {\lstfortran{a(1:3,1:3) = a(1:6:2,2:6:2)}} and
      \item[] {\lstfortran{a(1:3,1:3) = 1.0 }} are valid
      \item {\lstfortran{a(2:5,5) = a(2:5,1:6:2)}} and
      \item[] {\lstfortran{a(2:5,1:6:2) = a(1:6:2,2:6:2)}} are not
      \item {\lstfortran{a(2:5,5)}} is a 1D section while 
      \item[] {\lstfortran{a(2:5,1:6:2)}} is a 2D section
    \end{itemize}
    \column{4cm}
    \begin{center}
      \includegraphics[width=4cm,clip=true]{./array6}
    \end{center}
  \end{columns}
  \begin{itemize}
    \scriptsize
    \item The general form for specifying sub-arrays or sections is
    \item[] \textit{[<bound1>]:[<bound2>][:<stride>]}
    \item The section starts at \textit{<bound1>} and ends at or before \textit{<bound2>}.
    \item \textit{<stride>} is the increment by which the locations are selected, by default \textit{stride=1}
    \item \textit{<bound1>}, \textit{<bound2>}, \textit{<stride>} must all be scalar integer expressions.
  \end{itemize}

  \begin{lstlisting}[language={[90]Fortran}]
real, dimension(1:20) :: a
integer :: m,n,k
  \end{lstlisting}
  \begin{center}
    \scriptsize
    \begin{tabular}{lcl}
      {\lstfortran{a(:)}} &  & the whole array \\
      {\lstfortran{a(3:9)}} &  & elements 3 to 9 in increments of 1 \\
      {\lstfortran{a(3:9:1)}} &  & as above \\
      {\lstfortran{a(m:n)}} &  & elements m through n\\
      {\lstfortran{a(m:n:k)}} &  & elements m through n in increments of k \\
      {\lstfortran{a(15:3:-2)}} &  & elements 15 through 3 in increments of -2 \\
      {\lstfortran{a(15:3)}} &  & zero size array \\
      {\lstfortran{a(m:)}} &  & elements m through 20, default upper bound \\
      {\lstfortran{a(:n)}} &  & elements 1, default lower bound through n \\
      {\lstfortran{a(::2)}} &  & all elements from lower to upper bound in increments of 2 \\
      {\lstfortran{a(m:m)}} &  & 1 element section \\
      {\lstfortran{a(m)}} &  & array element not a section \\
      are valid sections. & & \\
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Array I/O}
  \begin{itemize}
    \item[] \lstfortran{real,dimension(4,4) :: a}
    \item Arrays are printed in the order that they appear in memory
    \item[] \lstfortran{print *, a}
    \item[] would produce on output
    \item[] \lstinline[mathescape]{a(1,1),a(2,1),a(3,1),a(4,1),a(1,2),a(2,2),$\cdots$,a(3,4),a(4,4)}
    \item[] \lstfortran{read *, a}
    \item[] would read from input and assign array elements in the same order as above
    \item The order of array I/O can be changed using intrinsic functions such as \lstfortran{reshape, transpose} or \lstfortran{cshift}.
      \framebreak
    \item Example: consider a 3x3 matrix
      \begin{center}
        \begin{tabular}{|c|c|c|}
          \hline
          1 & 4 & 7 \\ \hline
          2 & 5 & 8 \\ \hline
          3 & 6 & 9 \\ \hline
        \end{tabular}
      \end{center}
      \item The following print statements
        \begin{lstlisting}[language={[90]Fortran}]
 print *, 'array element   = ',a(3,3)
 print *, 'array section   = ',a(:,2)
 print *, 'sub-array       = ',a(:3,:2)
 print *, 'whole array     = ',a
 print *, 'array transpose = ',transpose(a)
        \end{lstlisting}
      \item would produce the following output
        \begin{Verbatim}[formatcom=\color{indigo}]
 array element   = 9
 array section   = 4 5 6
 sub-array       = 1 2 3 4 5 6
 whole array     = 1 2 3 4 5 6 7 8 9
 array transpose = 1 4 7 2 5 8 3 6 9
        \end{Verbatim}
    \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Array Intrinsic Functions}
  \begin{description}
    \item[{size(x[,n])}] The size of x (along the $n^{th}$ dimension, optional)
    \item[shape(x)] The shape of x
    \item[{lbound(x[,n])}] The lower bound of x
    \item[{ubound(x[,n])}] The upper bound of x
    \item[minval(x)] The minimum of all values of x
    \item[maxval(x)] The maximum of all values of x
    \item[minloc(x)] The indices of the minimum value of x
    \item[maxloc(x)] The indices of the maximum value of x
    \item[{sum(x[,n])}] The sum of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $sum(x) = \sum_{i,j,k,\cdots}x_{i,j,k,\cdots}$
      \framebreak
    \item[{product(x[,n])}] The product of all elements of x (along the $n^{th}$ dimension, optional)
    \item[] $prod(x) = \prod_{i,j,k,\cdots}x_{i,j,k,\cdots}$
    \item[transpose(x)] Transpose of array x: $ x_{i,j}\Rightarrow x_{j,i}$
    \item[dot\_product(x,y)] Dot Product of arrays x and y: $ \sum_{i} x_i* y_i $
    \item[matmul(x,y)] Matrix Multiplication of arrays x and y which can be 1 or 2 dimensional arrays: $ z_{i,j} = \sum_k x_{i,k} * y_{k,j}$
    \item[conjg(x)] Returns the conjugate of x: $ a + \imath b \Rightarrow a - \imath b$
    \item[cshift(ARRAY, SHIFT, dim)] perform a circular shift by SHIFT positions to the left on array ARRAY along the dim$^{\mathrm{th}}$ dimension
  \end{description}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Allocatable Arrays}
  \begin{block}{\scriptsize Why?}
    \begin{itemize}
      \item At compile time we may not know the size an array needs to be
      \item We may want to change the problem size without recompiling
      \item The molecular dynamics code was written for 4000 atoms. If you want to run a simulation for 256 and 1024 atoms, do you need to recompile and create two executables?
    \end{itemize}
  \end{block}
  \begin{itemize}
    \item Allocatable arrays allow us to set the size at run time.
    \item[] \lstfortran{real, allocatable :: force(:,:)}
    \item[] \lstfortran{real, dimension(:), allocatable :: vel}
    \item We set the size of the array using the allocate statement.
    \item[] \lstfortran{allocate(force(natoms,3))}
    \item We may want to change the lower bound for an array
    \item[] \lstfortran{allocate(grid(-100,100))}
    \item We may want to use an array once somewhere in the program, say during initialization. Using allocatable arrays also us to dynamically create the array when needed and when not in use, free up memory using the \lstfortran{deallocate} statement
    \item[] \lstfortran{deallocate(force,grid)}
    \item Sometimes, we want to check whether an array is allocated or not at a particular part of the code
    \item Fortran provides an intrinsic function, \lstfortran{allocated} which returns a scalar logical value reporting the status of an array
    \item[] \lstfortran{if ( allocated(grid) ) deallocate(grid)}
    \item[] \lstfortran{if ( .not. allocated(force) ) allocate(force(natoms,3))}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Masked Array Assignment: Where Statement}
  \begin{itemize}
    \item Masked array assignment is achieved using the \lstfortran{where} statement
    \item[] \lstfortran{where ( c < 2 ) a = b/c }
    \item[] the left hand side of the assignment must be array valued.
    \item[] the mask (logical expression) and the right hand side of the assignment must all conform
    \item Fortran 95/2003 introduced the \lstfortran{where ... elsewhere ... end where} functionality
    \item \lstfortran{where} statement cannot be nested
  \end{itemize}
  \begin{columns}[t]
    \column{4.8cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
 ! Apply PBC to coordinates
 where ( coord(i,:) > boxl(:) )
    coord(i,:) = coord(i,:) - boxl(:)
 elsewhere ( coord(i,:) < 0d0 )
    coord(i,:) = coord(i,:) + boxl(:)
 end where
    \end{lstlisting}
    \column{5.5cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
 ! Apply PBC to coordinates
 do j = 1, 3
    if ( coord(i,j) > boxl(j) ) then
       coord(i,j) = coord(i,j) - boxl(j)
    else if ( coord(i,j) < 0d0 ) then
       coord(i,j) = coord(i,j) + boxl(j)
    endif
 end do
    \end{lstlisting}
  \end{columns}
\end{frame}

%\begin{frame}[fragile]{Vector valued subscripts}
%  \begin{itemize}
%    \item A 1D array can be used to subscript an array in a dimension
%    \item[] \lstfortran{real, dimension(15) :: a}
%    \item[] \lstfortran{integer, dimension(5) :: v = (/ 1,4,8,10,15/)}
%    \item[] \lstfortran{integer, dimension(3) :: w = (/ 1,2,3/)}
%    \item[$\vardiamond$] {\lstfortran{a(v)}} is {\lstfortran{a(1), a(4), a(8), a(10)}} and {\lstfortran{a(15)}}
%    \item[$\vardiamond$] {\lstfortran{a(v) = 1.2}} is valid
%    \item[$\vardiamond$] only 1D vector subscripts are allowed
%    \item[] {\lstfortran{a(1) = prod(c(v,w))}}
%  \end{itemize}
%\end{frame}

\section{Procedures}
\begin{frame}[fragile,allowframebreaks]{Program Units}

  \begin{itemize}
    \item Most programs are hundreds or more lines of code.
    \item Use similar code in several places.
    \item A single large program is extremely difficult to debug and maintain.
    \item Solution is to break up code blocks into procedures
    \begin{description}
      \item[Subroutines:] Some out-of-line code that is called exactly where it is coded
      \item[Functions:] Purpose is to return a result and is called only when the result is needed
      \item[Modules:] A module is a program unit that is not executed directly, but contains data specifications
and procedures that may be utilized by other program units via the use statement.
    \end{description}
  \end{itemize}

  \framebreak

  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
program main 

  use module1 ! specify which modules to use

  implicit none  ! implicit typing is not recommended
  variable declarations  ! declare all variables used in the program

  $\vdots$  ! executable statements in seqeunce

  call routine1(arg1,arg2,arg3) ! call subroutine routine1 with arguments
  $\vdots$
  abc = func(arg1,arg2) ! abc is some function of arg1 and arg2
  $\vdots$

  contains  ! internal procedures are listed below

    subroutine routine1(arg1,arg2)  ! subroutine routine1 contents go here
      $\vdots$
    end subroutine routine1  ! all program units must have an end statement

    function func(arg1,arg2) ! function func1 contents go here
      ...
    end function func

  end program main
  \end{lstlisting}
  \framebreak
  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily]{./MolDyn/orig/md-orig.f90}
\end{frame}

\begin{frame}[fragile, allowframebreaks]{Subroutines}
  \begin{itemize}
    \item Call Statement: 
      \begin{itemize}
        \item The \lstfortran{call} statement evaluates its arguments and transfers control to the subroutine\\
        \item Upon return, the next statement is executed.
      \end{itemize}
    \item SUBROUTINE Statement:
      \begin{itemize}
        \item The \lstfortran{subroutine} statement declares the procedure and its arguments.\\
        \item These are also known as dummy arguments.
      \end{itemize}
    \item The subroutine's interface is defined by
      \begin{itemize}
        \item The \lstfortran{subroutine} statement itself
        \item The declarations of its dummy arguments
        \item Anything else that the subroutine uses
%        \item In the previous example, the \lstfortran{subroutine verlet} is an external procedure and can be called by any program unit with the program.
      \end{itemize}
      \framebreak
    \item Statement Order
      \begin{enumerate}
        \item A \lstfortran{subroutine} statement starts a subroutine
        \item Any \lstfortran{use} statements come next
        \item \lstfortran{implicit none} comes next, followed by
        \item rest of the declarations,
        \item executable statements
        \item End with a \lstfortran{end subroutine} statement
      \end{enumerate}
    \item Dummy Arguments
      \begin{itemize}
        \item Their names exist only in the procedure and are declared as local variables.
        \item The dummy arguments are associated with the actual arguments passed to the subroutines.
        \item The dummy and actual argument lists must match, i.e. the number of arguments must be the same and each argument must match in type and rank.
      \end{itemize}
  \end{itemize}
  \framebreak
  \vspace{-0.5cm}
  \begin{columns}[t]
    \column{0.5\textwidth}
      \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{3.5}{4}\selectfont\ttfamily]{./Code/verlet.f90}
    \column{0.5\textwidth}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{3.5}{4.5}\selectfont\ttfamily,mathescape]
program md

$\cdots$

  real(dp), dimension(:,:), allocatable :: coord_t0, coord
  real(dp), dimension(:,:), allocatable :: vel_t0, vel
  real(dp), dimension(:,:), allocatable :: acc_t0, acc, force
  real(dp) :: pener

  interface
     $\cdots$
     subroutine verlet(coord, coord_t0, vel_t0, vel, acc_t0, acc, force, pener)
       use precision
       implicit none
       real(dp), dimension(:,:), intent(in) :: coord_t0, vel_t0, acc_t0
       real(dp), dimension(:,:), intent(out) :: coord, vel, acc, force
       real(dp), intent(out) :: pener
     end subroutine verlet
     $\cdots$
  end interface

  $\cdots$

  do istep = 1, nstep

     ! Set coordinates, velocity, acceleration and force at next time step to zero
     coord = 0d0 ; vel = 0d0 ; acc = 0d0
     force = 0d0 ; pener = 0d0
     
     ! Get new atom positions from Velocity Verlet Algorithm
     call verlet(coord, coord_t0, vel_t0, vel, acc_t0, acc, force, pener)

     $\cdots$
  end do

  ! Free up memory
  deallocate(coord_t0,vel_t0,acc_t0,coord,vel,acc,force)

end program md

      \end{lstlisting}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Internal Procedures}
  \begin{itemize}
    \item Internal procedures appear just before the last \lstfortran{end} statement and are preceeded by the \lstfortran{contains} statement.
    \item Internal procedures can be either subroutines or functions which can be accessed only by the program, subroutine or module in which it is present
    \item Internal procedures have declaration of variables passed on from the parent program unit
    \item If an internal procedure declares a variable which has the same name as a variable from the parent program unit then this supersedes the variable from the outer scope for the length of the procedure.
%    \item i.e. internal procedures are not global and connot be called by other program units.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Functions}
  \begin{itemize}
    \item \lstfortran{function}s operate on the same principle as \lstfortran{subroutine}s
    \item The only difference is that \lstfortran{function} returns a value and does not involve the \lstfortran{call} statement 
  \end{itemize}
  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{3.5}{4.5}\selectfont\ttfamily,multicols=2]{./Code/potential.f90}
\end{frame}

\begin{frame}[fragile]{Array-valued Functions}
  \begin{itemize}
    \item \lstfortran{function} can also return arrays
  \end{itemize}
%  \begin{columns}[t]
%    \column{5.5cm}
%    \begin{eblock}{Example}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,multicols=2]
module potential
  use precision
  implicit none
  real(dp) :: r2, r6, d2, d
  real(dp), parameter :: de = 0.176d0, a = 1.4d0, re = 1d0
  real(dp) :: exparre
  
contains
  subroutine lennard_jones(r,f,p)
    ! Lennard Jones Potential
    ! V = 4 * epsilon * [ (sigma/r)**12 - (sigma/r)**6 ]
    !   = 4 * epsilon * (sigma/r)**6 * [ (sigma/r)**2 - 1 ]
    !   = 4 * r**(-6) * [ r**(-2) - 1 ] for epsilon=sigma=1
    ! F_i = 48 * epsilon * (sigma/r)**6 * (1/r**2) * [ ( sigma/r)** 6 - 0.5 ] * i where i = x,y,z
    !     = 48 * r**(-8) * [ r**(-6) - 0.5 ] * i  for epsilon=sigma=1    implicit none
    implicit none
    real(dp), dimension(:), intent(in) :: r
    real(dp), dimension(:), intent(out) :: f
    real(dp), intent(out) :: p

    r2 = 1.d0 / dot_product(r,r)
    r6 = r2 ** 3

    f = dvdr_lj(r2, r6, r)
    p = pot_lj(r2, r6)
  end subroutine lennard_jones

  subroutine morse(r,f,p)
    ! Morse Potential
    ! V = D * [ 1 - exp(-a*(r - re)) ]^2
    ! F_i = 2*D * [ 1 - exp(-a*(r - re)) ] * a exp(-a*(r-re)) * i / r  
    implicit none
    real(dp), dimension(:), intent(in) :: r
    real(dp), dimension(:), intent(out) :: f
    real(dp), intent(out) :: p

    d2 = dot_product(r,r)
    d = sqrt(d2)
    exparre = exp( -a * (d - re ))
    
    f = dvdr_mp(exparre,r)
    p = pot_mp(exparre)
  end subroutine morse

  function pot_lj(r2, r6)
    implicit none
    real(dp), intent(in) :: r2, r6
    real(dp) :: pot_lj
    pot_lj = 4d0 * r6 * ( r6 - 1.d0 )
  end function pot_lj
  function pot_mp(exparre)
    implicit none
    real(dp), intent(in) :: exparre
    real(dp) :: pot_mp
    pot_mp = de * ( 1d0 - exparre )**2
  end function pot_mp

  function dvdr_lj(r2,r6,r)
    implicit none
    real(dp), intent(in) :: r2, r6, r
    real(dp), dimension(size(r)) :: dvdr_lj
    dvdr_lj = 48d0 * r2 * r6 * ( r6 - 0.5d0 ) * r
  end function dvdr_lj
  function dvdr_mp(exparre,r)
    implicit none
    real(dp), intent(in) :: exparre, r
    real(dp), dimension(size(r)) :: dvdr_mp
    dvdr_mp = 2d0 * de * a * (1d0 - exparre) * exparre * r
  end function dvdr_mp
end module potential
      \end{lstlisting}
%    \end{eblock}
%    \column{5.5cm}
%  \end{columns}
\end{frame}

\begin{frame}[fragile]{Recursive Procedures}
  \begin{itemize}
    \item In Fortran 90, recursion is supported as a feature
    \begin{enumerate}
      \item \lstfortran{recursive} procedures call themselves
      \item \lstfortran{recursive} procedures must be declared explicitly
      \item \lstfortran{recursive function} declarations must contain a \lstfortran{result} keyword, and 
      \item one type of declaration refers to both the function name and the result variable.
    \end{enumerate}
  \end{itemize}    
  \begin{columns}[t]
    \column{6cm}
      \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4.5}{5}\selectfont\ttfamily]{./Exercise/factorial.f90}
    \column{5cm}
      \begin{Verbatim}[fontsize=\fontsize{4.5}{5}\selectfont,formatcom=\color{indigo}]
[apacheco@qb4 Exercise] ./factorial
 enter integer whose factorial you want to calculate
10 
   10! =              3628800
[apacheco@qb4 Exercise] ./fact1
 Enter an integer < 15
10
  10!=        3628800
        \end{Verbatim}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Argument Association}
  \begin{itemize}
    \item Recall from MD code example the invocation
    \item[] \lstfortran{call linearmom(vel_t0)}
    \item and the subroutine declaration
    \item[] \lstfortran{subroutine linearmom(vel)}
    \item[]
    \item {\lstfortran{vel_t0}} is an actual argument and is associated with the dummy argument {\lstfortran{vel}}
    \item In {\lstfortran{subroutine linearmom}}, the name {\lstfortran{vel}} is an alias for {\lstfortran{vel_t0}}
    \item If the value of a dummy argument changes, then so does the value of the actual argument
    \item {\color{red}The actual and dummy arguments must correspond in type, kind and rank.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\small Local Objects}
  \begin{columns}
    \column{6cm}
    \begin{itemize}
      \item In \lstfortran{subroutine linearmom},
      \item[] \lstfortran{i} and \lstfortran{vcm} are local objects.
      \item Local Objects 
      \begin{enumerate}
        \item[$\vardiamond$] are created each time a procedure is invoked
        \item[$\vardiamond$] are destroyed when the procedure completes
        \item[$\vardiamond$] do not retain their values between calls
        \item[$\vardiamond$] do not exist in the programs memory between calls.
      \end{enumerate}
    \end{itemize}
    \column{4.5cm}
    \begin{eblock}{Example}
      \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily]{./Code/linearmom.f90}
    \end{eblock}
  \end{columns}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Optional \& Keyword Arguments}
  \begin{itemize}
    \item Optional Arguments
      \begin{itemize}
        \item allow defaults to be used for missing arguments
        \item make some procedures easier to use
      \end{itemize}
    \item once an argument has been omitted all subsequent arguments must be keyword arguments
    \item the \lstfortran{present} intrinsic can be used to check for missing arguments
    \item if used with external procedures then the \lstfortran{interface} must be explicit within the procedure in which it is invoked.
      \begin{columns}[t]
        \column{0.5\textwidth}
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,mathescape]
subroutine get_temp(vel,boltz)
  use precision
  use param, only : natom, avtemp, mass, kb
  implicit none
  real(dp), dimension(:,:), intent(in) :: vel
  real(dp), optional :: boltz
  integer(ip) :: i
  real(dp) :: ke

  if (present(boltz))kb = boltz
  ke = 0d0
  do i = 1, natom
     ke = ke + dot_product(vel(i,:),vel(i,:))
  end do
  avtemp = mass * ke / ( 3d0 * kb * real( natom - 1, dp))
  
end subroutine get_temp


        \end{lstlisting}
%        \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily]{./Code/get_temp.f90}
        \column{0.5\textwidth}
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,mathescape]
subroutine initialize(coord_t0, vel_t0, acc_t0)
$\cdots$
  interface
     subroutine linearmom(vel)
       use precision
       implicit none
       real(dp), dimension(:,:), intent(inout) :: vel
     end subroutine linearmom
     subroutine get_temp(vel, boltz)
       use precision
       implicit none
       real(dp), dimension(:,:), intent(in) :: vel
       real(dp), optional :: boltz
     end subroutine get_temp
  end interface
$\cdots$
  call get_temp(vel_t0)
$\cdots$
        \end{lstlisting}
      \end{columns}
    \item Keyword Arguments
      \begin{itemize}
        \item allow arguments to be specified in any order
        \item makes it easy to add an extra argument - no need to modify any calls
        \item helps improve readability of the program
        \item are used when a procedure has optional arguments
      \end{itemize}
    \item once a keyword is used, all subsequent arguments must be keyword arguments
    \item if used with external procedures then the \lstfortran{interface} must be explicit within the procedure in which it is invoked.
  \end{itemize}

  \begin{columns}
    \column{5.5cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
subroutine initialize(coord, vel, acc)

  ...
  real(dp),dimension(:,:), intent(out) :: coord, vel, acc
  ...
end subroutine initialize
    \end{lstlisting}
    \column{5.5cm}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
program md
         ...
     call initialize(coord_t0, vel_t0, acc_t0)
         ...
end program md
    \end{lstlisting}
  \end{columns}
  \framebreak
  \begin{itemize}
    \item \lstfortran{subroutine initialize} can be invoked using 
    \begin{enumerate}
      \item using the positional argument invocation
      \item using keyword arguments
    \end{enumerate}
    \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily,mathescape]
program md
$\cdots$
  interface
     subroutine initialize(coord, vel, acc)
       use precision
       implicit none
       real(dp), dimension(:,:), intent(out) :: coord, vel, acc
     end subroutine initialize
  end interface
$\cdots$
! All three calls give the same result.
  call initialize(coord_t0, vel_t0, acc_t0)
  call initialize(coord=coord_t0, acc=acc_t0, vel=vel_t0)
  call initialize(coord_t0, acc=acc_t0, vel=vel_t0)
$\cdots$
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Dummy Array Arguments}
  \begin{itemize}
    \item There are two main types of dummy array argument:
    \begin{enumerate}
      \item \textit{explicit-shape}: all bounds specified
%      \item[] \lstfortran{real, dimension(4,4), intent(in) :: explicit_shape}
      \item[] \lstinline[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily]{real, dimension(4,4), intent(in) :: explicit_shape}
      \item[] The actual argument that becomes associated with an explicit shape dummy must conform in size and shape
      \item \textit{assumed-shape}: no bounds specified, all inherited from the actual argument
      \item[] \lstinline[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily]{real, dimension(:,:), intent(out) :: assumed_shape}
      \item[] An explicit interface must be provided
      \item \textit{assumed-size}: final dimension is specified by $\ast$
      \item[] \lstinline[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily]{real :: assumed_size(dim1,dim2,*)}
      \item[] Commomly used in FORTRAN, use assumed-shape arrays in Modern Fortran.
    \end{enumerate}
    \item dummy arguments cannot be (unallocated) allocatable arrays.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Explicit-shape Arrays}
  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4.5}{5.5}\selectfont\ttfamily,mathescape]
program md
  use precision
  use param
  implicit none
  integer(ip) :: n, i, j, k, l
  real(dp), dimension(:,:), allocatable :: coord_t0, vel_t0, acc_t0
  real(dp), dimension(:,:), allocatable :: coord, vel, acc, force
  $\cdots$
  ! Allocate arrays
  allocate(coord(natom,3), coord_t0(natom,3))
  allocate(vel(natom,3), vel_t0(natom,3))
  allocate(acc(natom,3), acc_t0(natom,3))
  allocate(force(natom,3))

  !=================================================
  ! Initialize coordinates and random velocities
  !=================================================

  call initialize(coord_t0, vel_t0, acc_t0)

  $\cdots$
end program md

subroutine initialize(coord_t0, vel_t0, acc_t0)
  use precision
  use param, only : natom, npartdim, alat, rcell
  implicit none
  real(dp), dimension(natom,3) :: coord_t0, vel_t0, acc_t0
  integer(ip) :: n, i, j, k, l

  ! Set initial coordinates, velocity and acceleration to zero
  coord_t0 = 0d0 ; vel_t0 = 0d0 ; acc_t0 = 0d0
  $\cdots$
end subroutine initialize
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Assumed-Shape Arrays}
  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,mathescape]
program md
  use precision
  use param
  implicit none
  integer(ip) :: n, i, j, k, l
  real(dp), dimension(:,:), allocatable :: coord_t0, vel_t0, acc_t0
  real(dp), dimension(:,:), allocatable :: coord, vel, acc, force
  $\cdots$
  interface
     subroutine initialize(coord_t0, vel_t0, acc_t0)
       use precision
       implicit none
       real(dp), dimension(:,:), intent(out) :: coord_t0, vel_t0, acc_t0
     end subroutine initialize
     $\cdots$
  end interface
  $\cdots$
  ! Allocate arrays
  allocate(coord(natom,3), coord_t0(natom,3))
  allocate(vel(natom,3), vel_t0(natom,3))
  allocate(acc(natom,3), acc_t0(natom,3))
  allocate(force(natom,3))

  !=================================================
  ! Initialize coordinates and random velocities
  !=================================================

  call initialize(coord_t0, vel_t0, acc_t0)
  $\cdots$
end program md

subroutine initialize(coord_t0, vel_t0, acc_t0)
  use precision
  use param, only : natom, npartdim, alat, rcell
  implicit none
  real(dp), dimension(:,:), intent(out) :: coord_t0, vel_t0, acc_t0
  integer(ip) :: n, i, j, k, l

  ! Set initial coordinates, velocity and acceleration to zero
  coord_t0 = 0d0 ; vel_t0 = 0d0 ; acc_t0 = 0d0
  $\cdots$
end subroutine initialize
  \end{lstlisting}
%  \begin{itemize}
%    \scriptsize
%    \item The actual arguments cannot be vector subscribed array.
%    \item The actual argument cannot be an assumed-size array
%    \item In the procedure, bounds begin at 1
%    \item If using external procedure, an explicit interface must be described
%  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Automatic Arrays}
  \begin{itemize}
    \item Automatic Arrays: Arrays which depend on dummy arguments
    \begin{enumerate}
      \scriptsize
      \item their size is determined by dummy arguments
      \item they cannot have the \lstfortran{save} attribute or be initialized.
    \end{enumerate}
    \item The \lstfortran{size} intrinsic or dummy arguments can be used to declare automatic arrays.
      \begin{lstlisting}[language={[90]Fortran},mathescape,basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
program main
  implicit none
  integer :: i,j
  real, dimension(5,6) :: a
  $\vdots$
  call routine(a,i,j)
  $\vdots$
  contains
    subroutine routine(c,m,n)
      integer :: m,n
      real, dimension(:,:), intent(inout) :: c   ! assumed shape array
      real :: b1(m,n)                            ! automatic array
      real, dimension(size(c,1),size(c,2)) :: b2 ! automatic array
      $\vdots$
    end subroutine routine
end program main
      \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Save Attribute and Arrays}
  \begin{itemize}
    \item Declaring a variable (or array) as \lstfortran{save} gives it a static storage memory.
    \item i.e information about variables is retained in memory between procedure calls.
      \begin{lstlisting}[language={[90]Fortran},mathescape,basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
subroutine something(iarg1)
  implicit none
  integer, intent(in) :: iarg1 
  real,dimension(:,:),allocatable,save :: a 
  real, dimension(:,:),allocatable :: b 
  $\vdots$ 
  if (.not.allocated(a))allocate(a(i,j)) 
  allocate(b(j,i))
  $\vdots$
  deallocate(b)
end subroutine something
      \end{lstlisting}
    \item Array {\lstfortran{a}} is saved when {\lstfortran{something}} exits.
    \item Array {\lstfortran{b}} is not saved and needs to be allocated every time in {\lstfortran{something}}  and deallocated, to free up memory, before {\lstfortran{something}} exits.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Intent}
  \begin{itemize}
    \item \lstfortran{intent} attribute was introduced in Fortran 90 and is recommended as it
    \begin{enumerate}
      \item allows compilers to check for coding errors
      \item facilitates efficient compilation and optimization
    \end{enumerate}
    \item Declare if a parameter is
    \begin{enumerate}
      \item[$\vardiamond$]Input: \lstfortran{intent(in)} 
      \item[$\vardiamond$]Output: \lstfortran{intent(out)}
      \item[$\vardiamond$]Both: \lstfortran{intent(inout)}
    \end{enumerate}
    \begin{lstlisting}[language={[90]Fortran},mathescape,basicstyle=\fontsize{6}{7}\selectfont\ttfamily]
subroutine verlet(coord, coord_t0, vel_t0, vel, acc_t0, acc, force, pener)
  use precision
  use param, only : natom, mass, boxl, dt
  implicit none
  real(dp),dimension(:,:), intent(in) :: coord_t0, vel_t0, acc_t0
  real(dp),dimension(:,:), intent(out) :: coord, vel, acc, force
  real(dp), intent(out) :: pener
$\vdots$
end subroutine verlet
    \end{lstlisting}
    \item A variable declared as \lstfortran{intent(in)} in a procedure cannot be changed during the execution of the procedure (see point 1 above)
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Interfaces}
  \begin{itemize}
    \item The \lstfortran{interface} statement is the first statement in an interface block.
    \item The \lstfortran{interface} block is a powerful structure that was introduced in FORTRAN 90.
    \item When used, it gives a calling procedure the full knowledge of the types and characteristics of the dummy arguments that are used inside of the procedure that it references.
    \item This can be a very good thing as it provides a way to execute some safety checks when compiling the program. 
    \item Because the main program knows what argument types should be sent to the referenced procedure, it can check to see whether or not this is the case.
    \item If not, the compiler will return an error message when you attempt to compile the program.
  \end{itemize}
  \framebreak
  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,multicols=2]{./Code/verlet1.f90}
  \framebreak
  \vspace{-0.5cm}
  \lstinputlisting[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,multicols=2]{./Code/verlet2.f90}
  \vspace{-0.5cm}
  \begin{itemize}
    \scriptsize
    \item Here since \lstfortran{subroutine get_pot\_force} is an internal procedure, no \lstfortran{interface} is required since it is already implicit and all variable declarations are carried over from \lstfortran{subroutine verlet}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Modules}
  \begin{itemize}
%    \item A module is a program unit that is not executed directly, but contains data specifications and procedures that may be utilized by other program units via the use statement.
    \item Modules were introduced in Fortran 90 and have a wide range of applications.
    \item Modules allow the user to write object based code.
    \item A \lstfortran{module} is a program unit whose functionality can be exploited by other programs which attaches to it via the \lstfortran{use} statement.
    \item A \lstfortran{module} can contain the following
    \begin{enumerate}
      \item global object declaration: replaces Fortran 77 \lstfortran{COMMON} and \lstfortran{INCLUDE} statements
      \item interface declaration: all external procedures using assumed shape arrrays, intent and keyword/optional arguments must have an explicit interface
      \item procedure declaration: include procedures such as subroutines or functions in modules. Since modules already contain explicit interface, an interface statement is not required
    \end{enumerate}
  \end{itemize}
  \framebreak
  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{4}{5}\selectfont\ttfamily,multicols=2]
module precision
  implicit none
  save
  integer, parameter :: ip = selected_int_kind(15)
  integer, parameter :: dp = selected_real_kind(15)
end module precision

module param
  use precision
  implicit none
  integer(ip) :: npartdim, natom, nstep, istep
  real(dp) :: tempK, dt, boxl(3), alat, mass
  real(dp) :: avtemp, ke, kb, epsilon, sigma, scale
  real(dp),dimension(3,4) :: rcell = reshape( (/ &
       0.0D+00, 0.0D+00, 0.0D+00, &
       0.5D+00, 0.5D+00, 0.0D+00, &
       0.0D+00, 0.5D+00, 0.5D+00, &
       0.5D+00, 0.0D+00, 0.5D+00 /), (/ 3, 4 /) )
  character(len=2) :: pot
end module param
  \end{lstlisting}
  \vspace{-0.5cm}
  \begin{itemize}
    \item within a \lstfortran{module}, functions and subroutines are called module procedures.
    \item \lstfortran{module} procedures can contain internal procedures
    \item \lstfortran{module} objects that retain their values should be given a \lstfortran{save} attribute
    \item \lstfortran{module}s can be used by procedures and other modules, see \lstfortran{module precision}.
    \item \lstfortran{module}s can be compiled separately. {\color{red}They should be compiled before the program unit that uses them}.
    \item[] Observe that in my examples with all code in single file, the \lstfortran{module}s appear before the main program and subroutines.
  \end{itemize}

  \framebreak
%  \begin{block}{\scriptsize Visibility of module procedures}
  \centering{\textbf{Visibility of module procedures}}
    \begin{itemize}
      \item By default, all module procedures are public i.e. they can accessed by program units that use the module using the \lstfortran{use} statement
      \item To restrict the visibility of the module procedure only to the module, use the \lstfortran{private} statement
      \item In the \lstfortran{module potential}, all functions which calculate forces can be declared as private as follows
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
module potential
  use precision
  implicit none
  real(dp) :: r2, r6, d2, d
  real(dp), parameter :: de = 0.176d0, a = 1.4d0, re = 1d0
  real(dp) :: exparre
  public :: lennard_jones, morse, pot_lj, pot_mp
  private :: dvdr_lj, dvdr_mp
  
contains
  $\cdots$
end module potential
      \end{lstlisting}
    \item Program Units in the MD code can directly call \lstfortran{lennard_jones, morse, pot_lj} and \lstfortran{pot_mp} but cannot access \lstfortran{dvdr_lj} and \lstfortran{dvdr_mp}
    \end{itemize}
%  \end{block}
  \framebreak
  \centering{\textbf{Using Modules}}
    \begin{itemize}
      \item The \lstfortran{use} statement names a module whole public definitions are to be made accessible.
      \item[] To use all variables from \lstfortran{module param} in \lstfortran{program md}:
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
        program md
          use param
          ...
        end program md
        \end{lstlisting}
      \item \lstfortran{module} entities can be renamed
      \item[] To rename \lstfortran{pot} and \lstfortran{dt} to more user readable variables:
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
        use param, pot => potential, dt => timestep
        \end{lstlisting}
      \item It's good programming practice to use only those variables from modules that are neccessary to avoid name conflicts and overwrite variables.
      \item For this, use the \lstfortran{use <modulename>, only} statement
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
        subroutine verlet(coord,force,pener)
          use param,only : dp,npart,boxl,tstep
          ...
        end subroutine verlet
            \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]{Compiling Modules}
  \begin{itemize}
    \item Consider the MD code containing a main program \Verblue{md.f90}, modules \Verblue{precision.f90}, \Verblue{param.f90} and \Verblue{potential.f90} and subroutines \Verblue{initialize.f90}, \Verblue{verlet.f90}, \Verblue{linearmom.f90} and \Verblue{get\_temp.f90}.
    \item In general, the code can be compiled as 
      \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
ifort -o md md.f90 precision.f90 param.f90 potential.f90 initialize.f90 \
   verlet.f90 linearmom.f90 get_temp.f90
      \end{Verbatim}
    \item Most compilers are restrictive in the order of compilation.
    \item The order in which the sub programs should be compiled is
    \begin{enumerate}
      \scriptsize
      \item Modules that do not use any other modules.
      \item Modules that use one or more of the modules already compiled.
      \item Repeat the above step until all modules are compiled and all dependencies are resolved.
      \item Main program followed by all subroutines and functions (if any).
    \end{enumerate}
    \item In the MD code, the module \Verblue{precision} does not depend on any other modules and should be compiled first
    \item The modules \Verblue{param} and \Verblue{potential} only depend on \Verblue{precision} and can be compiled in any order
    \item The main program and subroutines can then be compiled
      \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
ifort -o md md.f90 precision.f90 param.f90 potential.f90 initialize.f90 \
   verlet.f90 linearmom.f90 get_temp.f90
      \end{Verbatim}
    \item modules are designed to be compiled independently of the main program and create a \Verblue{.mod} files which need to be linked to the main executable.
      \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
ifort -c precision.f90 param.f90 potential.f90 
        creates precision.mod param.mod potential.mod
      \end{Verbatim}
    \item The main program can now be compiled as
      \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
ifort -o md md.f90 initialize.f90 verlet.f90 linearmom.f90 get_temp.f90 \
   -I{path to directory containing the .mod files}
      \end{Verbatim}
    \item The Makefile tutorial will cover this aspect in more detail.
  \end{itemize}
\end{frame}

\section{Derived Types}
\begin{frame}[fragile,allowframebreaks]{Derived Types}
  \begin{itemize}
    \item Defined by user (also called structures)
    \item Can include different intrinsic types and other derived types
    \item Components are accessed using the percent operator (\%)
    \item Only assignment operator (=) is defined for derived types
    \item Can (re)define operators - see operator overloading
    \item Derived type definitions should be placed in a \lstfortran{module}.
    \item Previously defined type can be used as components of other derived types.
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
type line_type
  real :: x1, y1, x2, y2
end type line_type

type(line_type) :: a, b

type vector_type
  type(line_type) :: line ! defines x1,y1,x2,y2
  integer :: direction ! 0=nodirection, 1=(x1,y1)->(x2,y2)
end type vector_type

type(vector_type) :: c, d
      \end{lstlisting}
    \framebreak
    \item values can be assigned to derived types in two ways
    \begin{enumerate}
      \item component by component
      \item[] individual component may be selected using the \% operator
      \item as an object
      \item[] the whole object may be selected and assigned to using a constructor
    \end{enumerate}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
        a%x1 = 0.0 ; a%x2 = 0.5 ; a%y1 = 0.0 ; a%y2 = 0.5
        
        c%direction = 0 
        c%line%x1 = 0.0 ; c%line%x2 = 1.0 
        c%line%y1 = -1.0 ; c%line%y2 = 0.0

        b = line_type(0.0, 0.0, 0.5, 0.5)

        d%line = line_type(0.0, -1.0, 1.0, 0.0)} 
        d = vector_type( d%line, 1 ) 
        ! or
        d = vector_type( line_type(0.0, -1.0, 1.0, 0.0), 1)
      \end{lstlisting}
      \framebreak
    \item Assigment between two objects of the same derived type is intrinsically defined
    \item[] In the previous  example: \lstfortran{a = b} is allowed but \lstfortran{a = c} is not.
  \end{itemize}
  \begin{columns}
    \column{0.6\textwidth}
    \begin{eblock}{}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
coord_t0(n)%x = alat * real(i - 1, dp) + rcell(1,l)
coord_t0(n)%y = alat * real(j - 1, dp) + rcell(2,l)
coord_t0(n)%z = alat * real(k - 1, dp) + rcell(3,l)
  OR
x = alat * real(i - 1, dp) + rcell(1,l)
y = alat * real(j - 1, dp) + rcell(2,l)
z = alat * real(k - 1, dp) + rcell(3,l)
coord_t0(n) = dynamics( x, y, z )
      \end{lstlisting}
    \end{eblock}
  \end{columns}
  \begin{itemize}
    \item I/O on Derived Types
    \begin{itemize}
      \item Can do normal I/O on derived types
      \item[] \lstfortran{print *, a} will produce the result \lstfortran{1.0  0.5  1.5}
      \item[] \lstfortran{print *, c} will produce the result \lstfortran{2.0  0.0  0.0  0.0}
    \end{itemize}
    \item Arrays and Derived Types
    \begin{itemize}
      \item Can define derived type objects which contain non-allocatable arrays and arrays of derived type objects
    \end{itemize}
    \item Derived Type Valued Functions
    \begin{itemize}
      \item Functions can return results of an arbitrary defined type.
    \end{itemize}

  \item Private Derived Types
    \begin{itemize}
      \item A derived type can be wholly private or some of its components hidden
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,mathescape]
module data
  type :: position
    real, private :: x, y, z
  end type position
  type, private :: acceleration
    real, private :: x, y, z
  end type acceleration
  contains
  $\vdots$
end module data
          \end{lstlisting}
      \item Program units that use \lstfortran{data} have \lstfortran{position} exported but not it's components \lstfortran{x,y,z} and the derived type \lstfortran{acceleration}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Generic Procedures}
  \begin{itemize}
    \item In Fortran, most intrinsic functions are generic in that their type is determined by their argument(s)
    \item For example, the \lstfortran{abs(x)} intrinsic function comprises of
    \begin{enumerate}
      \item \lstfortran{cabs} : called when \lstfortran{x} is \lstfortran{complex}
      \item \lstfortran{abs} : called when \lstfortran{x} is \lstfortran{real}
      \item \lstfortran{iabs} : called when \lstfortran{x} is \lstfortran{integer}
    \end{enumerate}
    \item These sets of functions are called \textit{overload sets}
    \item Fortran users may define their own \textit{overload sets} in an \lstfortran{interface} block
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
  interface clear
     module procedure clear_real, clear_type, clear_type1D
  end interface
      \end{lstlisting}
    \item The generic name \lstfortran{clear} is associated with specific names \lstfortran{clear\_real, clear\_type, clear\_type1D}
  \end{itemize}
  \framebreak
  {\fontsize{4}{5}
    \begin{columns}[t]
      \column{5cm}
      \vspace{-0.5cm}
      \begin{eblock}{}
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
module dynamic_data
  ...
  type dynamics
     real(dp) :: x,y,z
  end type dynamics
  interface dot_product
     module procedure dprod
  end interface dot_product
  interface clear
     module procedure clear_real, clear_type, clear_type1D
  end interface
contains
  function dprod(a,b) result(c)
    type(dynamics),intent(in) :: a,b
    real(dp) :: c
    c = a%x * b%x + a%y * b%y + a%z * b%z
  end function dprod
  subroutine clear_real(a)
    real(dp),dimension(:,:),intent(out) :: a
    a = 0d0
  end subroutine clear_real

  subroutine clear_type(a)
    type(dynamics),dimension(:),intent(out) :: a
    a%x = 0d0 ; a%y = 0d0 ; a%z = 0d0
  end subroutine clear_type

  subroutine clear_type1D(a)
    type(dynamics),intent(out) :: a
    a%x = 0d0 ; a%y = 0d0 ; a%z = 0d0
  end subroutine clear_type1D
end module dynamic_data
        \end{lstlisting}
      \end{eblock}
      \column{6cm}
      \vspace{-0.5cm}
      \begin{eblock}{}
        \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
program md
  use dynamic_data
  ...
  type(dynamics),dimension(:),allocatable :: coord,coord0,vel,force
  ...
  allocate(coord(npart),coord0(npart),vel(npart),force(npart))
  ...
     do i=1,npart
        v2t = v2t + dot_product(vel(i),vel(i))
     enddo
  ...
end program md

subroutine setup(coord,vel,coord0)
  ...
  type(dynamics) :: vt
  ...
  call clear(coord)
  call clear(coord0)
  call clear(vel)
  ...
  call clear(vt)
  ...
end subroutine setup
        \end{lstlisting}
      \end{eblock}
    \end{columns}
  }
  \begin{itemize}
    \item The \lstfortran{dot\_product} intrinsic function is overloaded to inlcude derived types
    \item The procedure \lstfortran{clear} is overloaded to set all components of derived types and all elements of 2D real arrays to zero. 
  \end{itemize}
\end{frame}

\begin{frame}[fragile, allowframebreaks]
  \frametitle{\small Operator Overloading}
  \begin{itemize}
    \item Intrinsic operators such as +, -, * and / can be overloaded to apply to all types of data
    \item Recall, for derived types only the assignment (=) operator is defined
    \item In the MD code, \lstfortran{coord\_t(i) = coord\_t0(i)} is well defined, but \lstfortran{vel\_t(i) = vel\_t(i) * scalef} is not
    \item Operator overloading as follows
    \begin{enumerate}
      \item specify the generic operator symbol in an \lstfortran{interface operator} statement
      \item specify the overload set in a generic interface
      \item declare the \lstfortran{module procedure}s (\lstfortran{function}s) which define how the operations are implemented.
      \item these functions must have one or two non-optional arguments with \lstfortran{intent(in)} which correspond to monadic or dyadic operators
    \end{enumerate}
  \end{itemize}
  \framebreak
  \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily,multicols=2]
module dynamic_data
  ...
  type dynamics
     real(dp) :: x,y,z
  end type dynamics

  interface operator (*)
     module procedure scale_tr, scale_rt
  end interface operator (*)
  interface operator (+)
     module procedure add
  end interface operator (+)
contains
  type(dynamics) function scale_tr(a,b) result(c)
    type(dynamics),intent(in)::a
    real(dp),intent(in) :: b
    type(dynamics) :: c
    c%x = a%x * b
    c%y = a%y * b
    c%z = a%z * b
  end function scale_tr
  type(dynamics) function scale_rt(b,a) result(c)
    type(dynamics),intent(in)::a
    real(dp),intent(in) :: b
    type(dynamics) :: c
    c%x = b * a%x
    c%y = b * a%y
    c%z = b * a%z
  end function scale_rt
  type(dynamics) function add(a,b) result(c)
    type(dynamics),intent(in) :: a,b
    type(dynamics) :: c
    c%x = a%x + b%x
    c%y = a%y + b%y
    c%z = a%z + b%z
  end function add
end module dynamic_data
  \end{lstlisting}
  \begin{itemize}
    \item The following operations are now defined for derived types \lstfortran{a,b,c} and scalar \lstfortran{r}
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily]
c = a * r
c = r * a
c = a + b
      \end{lstlisting}
    \item If operator overloading is not defined, the above operations would have to be executed as follows whereever needed
      \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{7}{8}\selectfont\ttfamily]
c%x = a%x * r
c%y = a%y * r
c%z = a%z * r

c%x = r * a%x
c%y = r * a%y
c%z = r * a%z

c%x = a%x + b%x
c%y = a%y + b%y
c%z = a%z + b%z 
      \end{lstlisting}
  \end{itemize}
\end{frame}

\section{Object Based Programming}
\begin{frame}
  \frametitle{\small OOP Concepts}
  \begin{itemize}
    \item Fortran 90 has some Object Oriented facilites such as
    \begin{enumerate}
      \item data abstraction: user defined types (covered)
      \item data hiding - private and public attributes (covered)
      \item encapsulation - modules and data hiding facilities (covered)
      \item inheritance and extensibility - super-types, operator overloading and generic procedures (covered)
      \item polymorphism - user can program his/her own polymorphism by generic overloading
      \item resuability - modules
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Pointers}
  \begin{itemize}
    \item In Fortran, a \lstfortran{pointer} variable or simply a \lstfortran{pointer} is best thought of as a ``free-floating'' name that may be associated with or ``aliased to'' some object.
    \item The object may already have one or more other names or it may be an unnamed object.
    \item The object represent data (a variable, for example) or be a procedure.
    \item A \lstfortran{pointer} is any variable that has been given the \lstfortran{pointer} attribute.
    \item A variable with the \lstfortran{pointer} attribute may be used like any ordinary variable.
      \framebreak
    \item Each pointer is in one of the following three states:
      \begin{itemize}
        \item[undefined] condition of each \lstfortran{pointer} at the beginning of a \lstfortran{program}, unless it has been initialized
        \item[null] not an alias of any data object
        \item[associated] it is an alias of some target data object
      \end{itemize}
    \item \lstfortran{pointer} objects must be declared with the \lstfortran{pointer} attribute
    \item[] \lstfortran{real, pointer :: p}
    \item Any variable aliased or ``pointed to'' by a \lstfortran{pointer} must be given the \lstfortran{target} attribute
    \item[] \lstfortran{real, target :: r}
    \item To make \lstfortran{p} an alias to \lstfortran{r}, use the \lstfortran{pointer assignment statement}
    \item[] \lstfortran{p => r}
      \framebreak
    \item The variable declared as a \lstfortran{pointer} may be a simple variable as above, an array or a structure
    \item[] \lstfortran{real, dimension(:), pointer :: v}
    \item \lstfortran{pointer v} declared above can now be aliased to a 1D array of reals or a row or column of a multi-dimensional array
    \item[] \lstfortran{real, dimension(100,100), target :: a}
    \item[] \lstfortran{v => a(5,:)}
    \item \lstfortran{pointer} variables can be used as any other variables
    \item[] For example, \lstfortran{print *, v} and \lstfortran{print *, a(5,:)} are equivalent
    \item[] \lstfortran{v = 0.0 } is the same as \lstfortran{a(5,:) = 0.0}
    \item \lstfortran{pointer} variables can also be an alias to another \lstfortran{pointer} variable
  \end{itemize}
  \framebreak
  \begin{columns}[t]
    \column{5.5cm}
    \begin{bblock}{}
      \begin{itemize}
        \item Consider the following example
          \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
real, target :: r
real, pointer :: p1, p2
r = 4.7
p1 => r
p2 => r
print *, r, p1, p2
r = 7.4
print *, r, p1, p2
          \end{lstlisting}
        \item The output on the screen will be
          \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
4.7  4.7  4.7
7.4  7.4  7.4
          \end{Verbatim}
        \item Changing the value of \lstfortran{r} to 7.4 causes the value of both \lstfortran{p1} and \lstfortran{p2} to change to 7.4
      \end{itemize}
    \end{bblock}
    \column{5.5cm}
    \begin{bblock}{}
      \begin{itemize}
        \item Consider the following example
          \begin{lstlisting}[language={[90]Fortran},basicstyle=\fontsize{5}{6}\selectfont\ttfamily]
real, target :: r1, r2
real, pointer :: p1, p2
r1 = 4.7 ; r2 = 7.4
p1 => r1 ; p2 => r2
print *, r1, r2, p1, p2
p1 = p2
print *, r1, r2, p1, p2
          \end{lstlisting}
        \item The output on the screen will be
          \begin{Verbatim}[fontsize=\fontsize{6}{7}\selectfont,formatcom=\color{indigo}]
4.7  7.4  4.7  7.4
4.7  4.7  4.7  4.7
          \end{Verbatim}
        \item The assignment statement \lstfortran{p2 = p1} has the same effect of \lstfortran{r2 = r1} since \lstfortran{p1} is an alias to \lstfortran{r1} and \lstfortran{p2} is an alias to \lstfortran{r2}
      \end{itemize}
    \end{bblock}
  \end{columns}

  \begin{itemize}
    \item The \lstfortran{allocate} statement can be used to create space for a value and cause a pointer to refer to that space.
    \item[] \lstfortran{allocate(p1)} creates a space for one real number and makes \lstfortran{p1} an alias to that space.
    \item No real value is stored in that space so it is neccessary to assign a value to \lstfortran{p1}
    \item \lstfortran{p1 = 4.7} assigns a value 4.7 to that allocated space
    \item Before a value is assigned to \lstfortran{p1}, it must either be associated with an unnamed target using the \lstfortran{allocate} statement or be aliased with a target using the pointer assignment statement.
    \item \lstfortran{deallocate} statement dissociates the pointer from any target and nullifies it
    \item[] \lstfortran{deallocate(p1)}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\small Pointer Intrinsic Functions}
  \begin{itemize}
    \item null intrinsic
    \begin{itemize}
      \item \lstfortran{pointer} variables are undefined unless they are initialized
      \item \lstfortran{pointer} variable must not be reference to produce a value when it is undefined.
      \item It is sometime desirable to have a \lstfortran{pointer} variable in a state of not pointing to anything
      \item The \lstfortran{null} intrinsic function nullifies a pointer assignment so that it is in a state of not pointing to anything
      \item[] \lstfortran{p1 => null()}
      \item If the target of \lstfortran{p1} and \lstfortran{p2} are the same, then nullifying \lstfortran{p1} does not nullify \lstfortran{p2}
      \item If \lstfortran{p1} is null and \lstfortran{p2} is pointing to \lstfortran{p1}, then \lstfortran{p2} is also nullified.
    \end{itemize}
    \item associated intrinsic
    \begin{itemize}
      \item The \lstfortran{associated} intrinsic function queries whether a pointer varibale is pointing to, or is an alias for another object.
      \item[] \lstfortran{associated(p1,r1)} and \lstfortran{associated(p2,r2)} are true, but
      \item[] \lstfortran{associated(p1,r2)} and \lstfortran{associated(p2,r1)} are false
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{\small Extended Data Types}
  \begin{itemize}
    \item Recall the derived type example which has as a component another derived type
      \begin{lstlisting}[language={[90]Fortran}]
type, public :: line_type 
  real :: x1, y1, x2, y2
end type line_type 
type, public :: vector_type
  type(line_type) :: line !position of center of sphere
  integer :: direction ! 0=no direction, 1=(x1,y1)->(x2,y2) 
end type vector_type
      \end{lstlisting}
    \item An object, \lstfortran{c}, of type \lstfortran{vector\_type} is referenced as \lstfortran{c\%line\%x1, c\%line\%y1, c\%line\%x2, c\%line\%y2} and \lstfortran{c\%direction} which can be cumbersome.
      \framebreak
    \item In Fortran, it is possible to extend the base type \lstfortran{line\_type} to other types such as \lstfortran{vector\_type} and \lstfortran{painted\_line\_type} as follows
      \begin{lstlisting}[language={[90]Fortran}]
type, public, extends(line_type) :: vector_type 
  integer :: direction
end type vector_type 
type, public, extends(line_type) :: painted_line_type
  integer :: r, g, b ! rgb values 
end type painted_line_type
      \end{lstlisting}
    \item An object,\lstfortran{c} of type \lstfortran{vector\_type} inherits the components of the type \lstfortran{line\_type} and has components \lstfortran{x1,y1,x2,y2} and \lstfortran{direction} and is referenced as \lstfortran{c\%x1, c\%y1, c\%x1, c\%y2} and \lstfortran{c\%direction} 
    \item Similarly, an object, \lstfortran{d} of type \lstfortran{painted\_line\_type} is referenced as \lstfortran{d\%x1, d\%y2, d\%x2, d\%y2, d\%r, d\%g} and \lstfortran{d\%b}
    \item The three derived types constitute a \lstfortran{class}; the name of the class is the name of the base type \lstfortran{line\_type}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{\small References}
  \begin{itemize}
    \item Fortran 95/2003 Explained, Michael Metcalf
    \item Modern Fortran Explaned, Michael Metcalf
    \item Guide to Fortran 2003 Programming, Walter S. Brainerd
    \item Introduction to Programming with Fortran: with coverage of Fortran 90, 95, 2003 and 77, I. D. Chivers
    \item Fortran 90 course at University of Liverpool, \url{http://www.liv.ac.uk/HPC/F90page.html}
    \item Introduction to Modern Fortran, University of Cambridge, \url{http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Fortran}
    \item Scientific Programming in Fortran 2003: A tutorial Including Object-Oriented Programming, Katherine Holcomb, University of Virginia.
  \end{itemize}
\end{frame}


%\begin{frame}[fragile,allowframebreaks]
%  \frametitle{\small Polymorphism}
%  \begin{itemize}
%    \item A \lstfortran{polymorphic} variable is one that assumes different \lstfortran{types} at different times.
%    \item Such a variable is declared with the keyword \lstfortran{class} instead of \lstfortran{type}
%    \item A polymorphic object is dynamic by nature and must be declared to have either the \lstfortran{allocatable} or \lstfortran{pointer} attribute.
%    \item[] \lstfortran{class(coord), allocatable :: a}
%    \item[] This variable may be assigned a value that is a position for the center or a radius.
%    \item A polymorphic variable may not appear on the left side of an assignment statement
%    \item[] \lstfortran{a = vector\_type(x1,y1,x2,y2,direction)} is not allowed
%    \item Use the \lstfortran{allocate} statement to create and assign a value
%    \item[] \lstfortran{allocate(a, source=vector\_type(x1, y1, x2, y2, i))} ! where \lstfortran{x1, y1, x2, y2} and \lstfortran{i} are predefined variables.
%    \item Suppose, we want to define a type of line with both color and direction.
%    \item creating a type that extends both painted\_line\_type and vector\_type is not allowed
%    \item instead extend the type vector\_type to also include color since \lstfortran{direction=0} implies no vector
%      \begin{lstlisting}[language={[90]Fortran}]
%      type, public, extends(vector\_type) :: fancy\_line
%        integer :: r,g,b
%      end type fancy\_type
%      \end{lstlisting}
%    \item Now, \lstfortran{class(line\_type), allocatable ::} \lstfortran{colored\_line}
%    \item \lstfortran{allocate(colored\_line, source=fancy\_line(0.0, 0.0, 1.0, 1.5, 0, 255, 0, 0))}
%  \end{itemize}
%\end{frame}

\begin{frame}
  \frametitle{Additional Help}
  \begin{itemize}
    \item Online Courses: \url{http://moodle.hpc.lsu.edu}
    \item Contact us
    \begin{enumerate}
      {\scriptsize
        \item[$\vardiamond$]Email ticket system: sys-help@loni.org
        \item[$\vardiamond$]Telephone Help Desk: 225-578-0900
        \item[$\vardiamond$]Instant Messenger (AIM, Yahoo Messenger, Google Talk)
        \begin{enumerate}
          {\scriptsize
            \item[$\bigstar$]Add "lsuhpchelp"
          }
        \end{enumerate}
      }
    \end{enumerate}
  \end{itemize}
\end{frame}

\section{Exercise}
\begin{frame}
  \frametitle{\small Hands-On Exercise: Molecular Dynamics}
  \begin{itemize}
    \item Molecular Dynamics code for melting of solid Argon using Lennard-Jones Potential.
    \item Your goal is to rewrite the code using Modern Fortran concepts that you have grasped.
    \item This exercise is more of a "What concepts have I learned of Modern Fortran?", so there are multiple correct solutions
    \item Code can be obtained from \url{http://www.hpc.lsu.edu/training/archive/tutorials.php}:
    \item md-orig.f90 is the original code that you should begin working on (this is the same code that was shown in todays slides)
    \item There is no "correct solution", however there are multiple solutions md-v\{1-5\}.f90 based on various concepts presented.
    \item It's entirely up to you to decide which solution you want to arrive at.
%    \item Goal of this Hands-On Exercise should be to use as many features/Concepts of Fortran 90/95 that you have learned and still get the correct result.
    \item Compare the results of your edited code with that of md-v0.out. If the results are not the same, debug your code.
  \end{itemize}
\end{frame}

\subsection{Day 1 Exercises}
\begin{frame}[allowframebreaks]{Calculate pi by Numerical Integration}
  \begin{columns}
    \column{5cm}
    \begin{itemize}
      \item We know that
      \begin{align*}
        \int^1_0 \dfrac{4.0}{(1+x^2)}\, dx = \pi
      \end{align*}
      \item So numerically, we can approxiate pi as the sum of a number of rectangles
      \begin{align*}
        \sum^N_{i=0}\,F(x_i)\Delta x \approx \pi
      \end{align*}
      \item[] \fontsize{4}{5}{ Meadows et al, A ``hands-on'' introduction to OpenMP, SC09 }
    \end{itemize}
    \column{5cm}
    \begin{center}
      \includegraphics[width=4cm]{../OpenMP/pi}
    \end{center}
  \end{columns}

  \begin{algorithm}[H]
    \caption{Pseudo Code for Calculating Pi}
    \begin{algorithmic}
        \Function{calculate\_pi}{}
        \State $step \gets 1/n$
        \State $sum \gets 0$
        \Do{$i \gets 0\cdots n$}
        \State $x \gets (i+0.5)*step; sum \gets sum + 4/(1+x^2)$
        \EndDo
        \State $pi \gets sum * step$
        \EndFunction
    \end{algorithmic}
  \end{algorithm}
\end{frame}

\begin{frame}{\small SAXPY}
  \begin{itemize}
    \item SAXPY is a common operation in computations with vector processors included as part of the BLAS routines
    \item[] $y\leftarrow \alpha x + y$
%    \item SAXPY is a combination of scalar multiplication and vector addition
    \item Write a SAXPY code to multiply a vector with a scalar.
  \end{itemize}
  \begin{algorithm}[H]
    \caption{Pseudo Code for SAXPY}
    \begin{algorithmic}
      \Program{saxpy}{}
      \State $n \gets$ some large number
      \State $x(1:n) \gets$ some number say, 1
      \State $y(1:n) \gets$ some other number say, 2
      \State $a \gets$ some other number ,say, 3
      \Do{$i \gets 1\cdots n$}
      \State $y_i \gets y_i + a * x_i$
      \EndDo
      \EndProgram{saxpy}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

\begin{frame}[allowframebreaks]{Matrix Multiplication}
  \begin{itemize}
    \item Most Computational code involve matrix operations such as matrix multiplication.
    \item Consider a matrix {\bf C} which is a product of two matrices {\bf A} and {\bf B}:
    \item[] Element {\it i,j} of {\bf C} is the dot product of the $i^{th}$ row of {\bf A} and $j^{th}$ column of {\bf B}
    \item Write a MATMUL code to multiple two matrices.
  \end{itemize}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{../OpenMP/matmul}
  \end{center}

  \begin{algorithm}[H]
    \caption{Pseudo Code for MATMUL}
    \begin{algorithmic}
      \Program{matmul}{}
      \State $m,n \gets$ some\,large\,number $\le 1000$
      \State Define $a_{mn}, b_{nm}, c_{mm}$
      \State $a_{ij} \gets i+j; b_{ij} \gets i-j; c_{ij} \gets 0$
      \Do{$i \gets 1\cdots m$}
      \Do{$j \gets 1\cdots m$}
      \State $c_{i,j} \gets \sum^{n}_{k=1} a_{i,k}*b_{k,j}$
      \EndDo
      \EndDo
      \EndProgram{matmul}
    \end{algorithmic}
  \end{algorithm}
\end{frame}

%\begin{frame}<0>
%  \frametitle{}
%  \color{DarkBlue}{
%  \begin{center}
%    {\fontsize{40}{60}\selectfont The End}\\
%    \vspace{1cm}
%    {\fontsize{20}{30}\selectfont Any Questions?}\\
%    \vspace{0.5cm}
%    {\fontsize{15}{30}\selectfont
%      \color{red!80!black}{Next Week}\\      
%      \color{red!80!black}{Introduction to Perl}\\
%    }
%    \vspace{0.5cm}
%    {\fontsize{15}{20}\selectfont Survey: \color{red!90!white}{\url{http://www.hpc.lsu.edu/survey}}}
%  \end{center}
%  }
%\end{frame}

\end{document}

